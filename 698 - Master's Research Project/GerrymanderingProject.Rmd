---
title: "Measuring Gerrymandering with the Efficiency Gap"
author: "David Stern"
date: "April 24, 2016"
output: pdf_document
---


```{r,echo=FALSE}
suppressWarnings(suppressMessages(library(operators)))
suppressWarnings(suppressMessages(library(plyr)))
suppressWarnings(suppressMessages(library(ggplot2)))
suppressWarnings(suppressMessages(library(reshape2)))
suppressWarnings(suppressMessages(library(RCurl)))
suppressWarnings(suppressMessages(library(knitr)))
suppressWarnings(suppressMessages(library(grid)))
suppressWarnings(suppressMessages(library(gridExtra)))
suppressWarnings(suppressMessages(library(maptools)))
suppressWarnings(suppressMessages(library(spatstat)))
# load 2004
results2004 <- "https://raw.githubusercontent.com/TimeMagazine/congressional-election-results/master/data/results_2004.csv"
# https://s3.amazonaws.com/s3.azavea.com/com.redistrictingthenation/pdfs/Redistricting_The_Nation_Addendum.pdf
cd2004 <- getURL(results2004)
cd2004 <- read.csv(textConnection(cd2004))
suppressWarnings(cd2004$votes <- as.numeric(as.character(cd2004$votes)))
cd2004 <- subset(cd2004,district != "S")
cd2004$district[cd2004$district == "01 - FULL TERM"] <- "01"
cd2004$district[cd2004$district == "04 - FULL TERM"] <- "04"
cd2004$district[cd2004$district == "10 - FULL TERM"] <- "10"
cd2004$district[cd2004$district == "11 - FULL TERM"] <- "11"
d <- c("Democratic,Working Families","Working Families,Democratic",
       "Democratic,Progressive,Working Families","Democratic-Farmer Labor",
       "Democratic,Working Families,Independence","Democratic,Independence,Working Families",
       "Democratic-Nonpartisan League","Write-In,Democratic,Democratic","Democratic")
r <- c("Republican,Tax Revolt,Conservative,Independence","Republican,Tax Revolt,Conservative",
       "Republican,Tax Revolt","Republican,Conservative","Conservative,Republican",
       "Republican,Conservative,Libertarian","Republican,Conservative,Independence",
       "Independence,Republican","Independent Party,Republican", "Republican,Constitution",
       "Write-In,Republican,Republican","Conservative,Independence,Republican","Republican")

for (i in 1:length(cd2004$parties)){
  if (cd2004$parties[i] %in% d){
    cd2004$parties[i] <- "Democratic"
  }
  else if (cd2004$parties[i] %in% r){
    cd2004$parties[i] <- "Republican"
  }
}
# calc total vote by state
totalVoteByState2004 <- aggregate(votes ~ state, cd2004, sum)
# calc total vote by district
totalVoteByDistrict2004 <- aggregate(votes ~ state + district, cd2004, sum)
totalVoteByDistrict2004 <- totalVoteByDistrict2004[order(totalVoteByDistrict2004$state,totalVoteByDistrict2004$district),]
# add threshold of simple majority based on each district's vote total
totalVoteByDistrict2004$simpleMajority <- round(totalVoteByDistrict2004$votes/2 + 1,0)
partyTotalsByDistrict2004 <- aggregate(votes ~ state + district + parties, cd2004, sum)
partyTotalsByDistrict2004 <- partyTotalsByDistrict2004[order(partyTotalsByDistrict2004$state,partyTotalsByDistrict2004$district),]
partyTotalsByDistrict2004 <- join(partyTotalsByDistrict2004,totalVoteByDistrict2004,by=c("state","district"),type="left")
colnames(partyTotalsByDistrict2004)[5] <- "totalVote"
partyTotalsByDistrict2004 <- partyTotalsByDistrict2004[,c(1,2,5,6,4,3)]
partyTotalsByDistrict2004$pctVote <- partyTotalsByDistrict2004$votes/partyTotalsByDistrict2004$totalVote

allStates <- unique(partyTotalsByDistrict2004$state)
allDistricts <- unique(partyTotalsByDistrict2004$district)
partyTotalsByDistrict2004$win <- 0 #create column to indicate wins

for (i in 1:length(allDistricts)){
  for (j in 1:length(allStates)){
    row_to_find <- data.frame(state=allStates[j], district=allDistricts[i])
    if(nrow(merge(row_to_find,partyTotalsByDistrict2004))>0){
      subFrame <- subset(partyTotalsByDistrict2004,state==allStates[j] & district==allDistricts[i])
      w <- which.max(subFrame$pctVote)
      partyTotalsByDistrict2004[partyTotalsByDistrict2004$state==allStates[j] & 
                                  partyTotalsByDistrict2004$district==allDistricts[i],]$win[w] <- 1
    }
  }
}
partyTotalsByDistrict2004$wastedVote <- 0
partyTotalsByDistrict2004$wastedVote <- ifelse(partyTotalsByDistrict2004$win == 1 & 
                                                 partyTotalsByDistrict2004$votes > partyTotalsByDistrict2004$simpleMajority,
                                               partyTotalsByDistrict2004$votes - partyTotalsByDistrict2004$simpleMajority,
                                               ifelse(partyTotalsByDistrict2004$win == 1,0,partyTotalsByDistrict2004$votes))
seatsWon2004 <- aggregate(win ~ parties,partyTotalsByDistrict2004,sum)
seatsWon2004 <- subset(seatsWon2004,win!=0)
seatsWonByState2004 <- aggregate(win ~ state + parties,partyTotalsByDistrict2004,sum)
seatsWonByState2004 <- subset(seatsWonByState2004,win!=0)
seatsWonByState2004 <- seatsWonByState2004[order(seatsWonByState2004$state,-seatsWonByState2004$win),]
totalWastedVoteByParty2004 <- aggregate(wastedVote ~ parties, partyTotalsByDistrict2004, sum)
totalWastedVoteByParty2004 <- totalWastedVoteByParty2004[order(-totalWastedVoteByParty2004$wastedVote),]
totalVoteByParty2004 <- aggregate(votes ~ parties, partyTotalsByDistrict2004, sum)
totalVoteByParty2004 <- totalVoteByParty2004[order(-totalVoteByParty2004$votes),]
numDistricts <- data.frame(table(totalVoteByDistrict2004$state))
colnames(numDistricts) <- c("state","number")
numDistricts[9,2] <- 27 # correct, missing two from redistricting
totalWastedVoteByPartyByState2004 <- aggregate(wastedVote ~ state + parties, partyTotalsByDistrict2004, sum)
totalVoteByPartyByState2004 <- aggregate(votes ~ state + parties, partyTotalsByDistrict2004, sum)
totalVoteByPartyByState2004 <- totalVoteByPartyByState2004[order(totalVoteByPartyByState2004$state,-totalVoteByPartyByState2004$votes),]
totalWastedVoteByPartyByState2004 <- totalWastedVoteByPartyByState2004[order(totalWastedVoteByPartyByState2004$state,-totalWastedVoteByPartyByState2004$wastedVote),]
stateData2004 <- subset(totalWastedVoteByPartyByState2004,parties=="Democratic" | totalWastedVoteByPartyByState2004$parties=="Republican")
stateData2004 <- dcast(stateData2004,state ~ parties,value.var="wastedVote")
# bind number districts and total vote
stateData2004 <- join(stateData2004,numDistricts,by="state",type="left")
stateData2004 <- join(stateData2004,totalVoteByState2004,by="state",type="left")
stateData2004$efficiency.gap <- abs(stateData2004$Democratic-stateData2004$Republican)/stateData2004$votes
stateData2004$seats.misapportioned <- stateData2004$efficiency.gap*stateData2004$number
colnames(stateData2004)[2:5] <- c("w.votes.D","w.votes.R","seats","total.votes")
stateData2004$adv.R <- 0 
stateData2004$adv.D <- 0

totalVoteByPartyByState2004 <- subset(totalVoteByPartyByState2004,parties=="Democratic" | totalVoteByPartyByState2004$parties=="Republican")
totalVoteByPartyByState2004 <- dcast(totalVoteByPartyByState2004,state ~ parties,value.var="votes")
colnames(totalVoteByPartyByState2004)[2:3] <- c("d.votes","r.votes")
stateData2004 <- join(stateData2004,totalVoteByPartyByState2004,by="state",type="left")
# calculate projected seats
stateData2004$proj.D.seats <- (stateData2004$d.votes/stateData2004$total.votes)*stateData2004$seats
stateData2004$proj.R.seats <- (stateData2004$r.votes/stateData2004$total.votes)*stateData2004$seats
display <- stateData2004
seatsWonByState2004 <- dcast(seatsWonByState2004,state ~ parties,value.var="win",fill="0")
seatsWonByState2004$Democratic <- as.numeric(as.character(seatsWonByState2004$Democratic))
seatsWonByState2004$Republican <- as.numeric(as.character(seatsWonByState2004$Republican))
colnames(seatsWonByState2004)[2:3] <- c("act.D.seats","act.R.seats")
stateData2004 <- join(stateData2004,seatsWonByState2004,by="state",type="left")
stateData2004$voteratio <- ifelse(stateData2004$r.votes<stateData2004$d.votes,
                                  stateData2004$r.votes/stateData2004$d.votes,
                                  stateData2004$d.votes/stateData2004$r.votes)
stateData2004$majority <- ifelse(stateData2004$r.votes>stateData2004$d.votes,"R","D")

# efficiency gap by district
districtData2004 <- dcast(partyTotalsByDistrict2004,state + district + totalVote ~ parties,value.var="wastedVote",fill=0)
districtData2004$efficiency.gap <- abs(districtData2004$Democratic-districtData2004$Republican)/districtData2004$totalVote
districtData2004 <- districtData2004[,c("state","district","totalVote","Republican","Democratic","efficiency.gap")]
colnames(districtData2004)[4:5] <- c("w.votes.R","w.votes.D")
allPartyDistrictTotals2004 <- dcast(partyTotalsByDistrict2004,state + district ~ parties,value.var="votes",fill=0)
twoPartyDistrictTotals2004 <- allPartyDistrictTotals2004[,c("state","district","Republican","Democratic")]
colnames(twoPartyDistrictTotals2004)[3:4] <- c("votes.R","votes.D")
twoPartyDistrictTotals2004$vote.ratio <- ifelse(twoPartyDistrictTotals2004$votes.R<twoPartyDistrictTotals2004$votes.D,
                                                twoPartyDistrictTotals2004$votes.R/twoPartyDistrictTotals2004$votes.D,
                                                twoPartyDistrictTotals2004$votes.D/twoPartyDistrictTotals2004$votes.R)
districtData2004 <- join(districtData2004,twoPartyDistrictTotals2004,by=c("state","district"),type="left")
districtData2004$majority <- ifelse(districtData2004$votes.R>districtData2004$votes.D,"R","D")
districtData2004$margin <- (abs(districtData2004$votes.R-districtData2004$votes.D)/districtData2004$totalVote)*100
districtData2004$adv.R <- 0 
districtData2004$adv.D <- 0
for (i in 1:nrow(districtData2004)){
  if (districtData2004$w.votes.D[i] < districtData2004$w.votes.R[i]){
    districtData2004$adv.D[i] <- districtData2004$efficiency.gap[i]
  }
  else if (districtData2004$w.votes.R[i] < districtData2004$w.votes.D[i]){
    districtData2004$adv.R[i] <- districtData2004$efficiency.gap[i]
  }
}
sumAdv2004 <- aggregate(cbind(adv.R, adv.D) ~ state,districtData2004,sum)
sumAdv2004$state.seat.favor <- ifelse(sumAdv2004$adv.R>sumAdv2004$adv.D,"R","D")
sumAdv2004$state.seats.misapportioned <- abs(sumAdv2004$adv.R-sumAdv2004$adv.D)
sumAdv2004 <- sumAdv2004[,c(1,4,5)]
districtData2004 <- join(districtData2004,sumAdv2004,by="state",type="left")
# load 2006
results2006 <- "https://raw.githubusercontent.com/TimeMagazine/congressional-election-results/master/data/results_2006.csv"
# https://s3.amazonaws.com/s3.azavea.com/com.redistrictingthenation/pdfs/Redistricting_The_Nation_Addendum.pdf
cd2006 <- getURL(results2006)
cd2006 <- read.csv(textConnection(cd2006))
suppressWarnings(cd2006$votes <- as.numeric(as.character(cd2006$votes)))
cd2006 <- subset(cd2006,district != "S")
cd2006$district[cd2006$district == "01 - FULL TERM"] <- "01"
cd2006$district[cd2006$district == "04 - FULL TERM"] <- "04"
cd2006$district[cd2006$district == "10 - FULL TERM"] <- "10"
cd2006$district[cd2006$district == "11 - FULL TERM"] <- "11"
d <- c("Democratic,Working Families","Working Families,Democratic",
       "Democratic,Progressive,Working Families","Democratic-Farmer Labor",
       "Democratic,Working Families,Independence","Democratic,Independence,Working Families",
       "Democratic-Nonpartisan League","Write-In,Democratic,Democratic","Democratic")
r <- c("Republican,Tax Revolt,Conservative,Independence","Republican,Tax Revolt,Conservative",
       "Republican,Tax Revolt","Republican,Conservative","Conservative,Republican",
       "Republican,Conservative,Libertarian","Republican,Conservative,Independence",
       "Independence,Republican","Independent Party,Republican", "Republican,Constitution",
       "Write-In,Republican,Republican","Conservative,Independence,Republican","Republican")

for (i in 1:length(cd2006$parties)){
  if (cd2006$parties[i] %in% d){
    cd2006$parties[i] <- "Democratic"
  }
  else if (cd2006$parties[i] %in% r){
    cd2006$parties[i] <- "Republican"
  }
}
# calc total vote by state
totalVoteByState2006 <- aggregate(votes ~ state, cd2006, sum)
# calc total vote by district
totalVoteByDistrict2006 <- aggregate(votes ~ state + district, cd2006, sum)
totalVoteByDistrict2006 <- totalVoteByDistrict2006[order(totalVoteByDistrict2006$state,totalVoteByDistrict2006$district),]
# add threshold of simple majority based on each district's vote total
totalVoteByDistrict2006$simpleMajority <- round(totalVoteByDistrict2006$votes/2 + 1,0)
partyTotalsByDistrict2006 <- aggregate(votes ~ state + district + parties, cd2006, sum)
partyTotalsByDistrict2006 <- partyTotalsByDistrict2006[order(partyTotalsByDistrict2006$state,partyTotalsByDistrict2006$district),]
partyTotalsByDistrict2006 <- join(partyTotalsByDistrict2006,totalVoteByDistrict2006,by=c("state","district"),type="left")
colnames(partyTotalsByDistrict2006)[5] <- "totalVote"
partyTotalsByDistrict2006 <- partyTotalsByDistrict2006[,c(1,2,5,6,4,3)]
partyTotalsByDistrict2006$pctVote <- partyTotalsByDistrict2006$votes/partyTotalsByDistrict2006$totalVote

allStates <- unique(partyTotalsByDistrict2006$state)
allDistricts <- unique(partyTotalsByDistrict2006$district)
partyTotalsByDistrict2006$win <- 0 #create column to indicate wins

for (i in 1:length(allDistricts)){
  for (j in 1:length(allStates)){
    row_to_find <- data.frame(state=allStates[j], district=allDistricts[i])
    if(nrow(merge(row_to_find,partyTotalsByDistrict2006))>0){
      subFrame <- subset(partyTotalsByDistrict2006,state==allStates[j] & district==allDistricts[i])
      w <- which.max(subFrame$pctVote)
      partyTotalsByDistrict2006[partyTotalsByDistrict2006$state==allStates[j] & 
                                  partyTotalsByDistrict2006$district==allDistricts[i],]$win[w] <- 1
    }
  }
}
partyTotalsByDistrict2006$wastedVote <- 0
partyTotalsByDistrict2006$wastedVote <- ifelse(partyTotalsByDistrict2006$win == 1 & 
                                                 partyTotalsByDistrict2006$votes > partyTotalsByDistrict2006$simpleMajority,
                                               partyTotalsByDistrict2006$votes - partyTotalsByDistrict2006$simpleMajority,
                                               ifelse(partyTotalsByDistrict2006$win == 1,0,partyTotalsByDistrict2006$votes))
seatsWon2006 <- aggregate(win ~ parties,partyTotalsByDistrict2006,sum)
seatsWon2006 <- subset(seatsWon2006,win!=0)
seatsWonByState2006 <- aggregate(win ~ state + parties,partyTotalsByDistrict2006,sum)
seatsWonByState2006 <- subset(seatsWonByState2006,win!=0)
seatsWonByState2006 <- seatsWonByState2006[order(seatsWonByState2006$state,-seatsWonByState2006$win),]
totalWastedVoteByParty2006 <- aggregate(wastedVote ~ parties, partyTotalsByDistrict2006, sum)
totalWastedVoteByParty2006 <- totalWastedVoteByParty2006[order(-totalWastedVoteByParty2006$wastedVote),]
totalVoteByParty2006 <- aggregate(votes ~ parties, partyTotalsByDistrict2006, sum)
totalVoteByParty2006 <- totalVoteByParty2006[order(-totalVoteByParty2006$votes),]
numDistricts <- data.frame(table(totalVoteByDistrict2006$state))
colnames(numDistricts) <- c("state","number")
numDistricts[9,2] <- 27 # correct, missing two from redistricting
totalWastedVoteByPartyByState2006 <- aggregate(wastedVote ~ state + parties, partyTotalsByDistrict2006, sum)
totalVoteByPartyByState2006 <- aggregate(votes ~ state + parties, partyTotalsByDistrict2006, sum)
totalVoteByPartyByState2006 <- totalVoteByPartyByState2006[order(totalVoteByPartyByState2006$state,-totalVoteByPartyByState2006$votes),]
totalWastedVoteByPartyByState2006 <- totalWastedVoteByPartyByState2006[order(totalWastedVoteByPartyByState2006$state,-totalWastedVoteByPartyByState2006$wastedVote),]
stateData2006 <- subset(totalWastedVoteByPartyByState2006,parties=="Democratic" | totalWastedVoteByPartyByState2006$parties=="Republican")
stateData2006 <- dcast(stateData2006,state ~ parties,value.var="wastedVote")
# bind number districts and total vote
stateData2006 <- join(stateData2006,numDistricts,by="state",type="left")
stateData2006 <- join(stateData2006,totalVoteByState2006,by="state",type="left")
stateData2006$efficiency.gap <- abs(stateData2006$Democratic-stateData2006$Republican)/stateData2006$votes
stateData2006$seats.misapportioned <- stateData2006$efficiency.gap*stateData2006$number
colnames(stateData2006)[2:5] <- c("w.votes.D","w.votes.R","seats","total.votes")
stateData2006$adv.R <- 0 
stateData2006$adv.D <- 0

totalVoteByPartyByState2006 <- subset(totalVoteByPartyByState2006,parties=="Democratic" | totalVoteByPartyByState2006$parties=="Republican")
totalVoteByPartyByState2006 <- dcast(totalVoteByPartyByState2006,state ~ parties,value.var="votes")
colnames(totalVoteByPartyByState2006)[2:3] <- c("d.votes","r.votes")
stateData2006 <- join(stateData2006,totalVoteByPartyByState2006,by="state",type="left")
# calculate projected seats
stateData2006$proj.D.seats <- (stateData2006$d.votes/stateData2006$total.votes)*stateData2006$seats
stateData2006$proj.R.seats <- (stateData2006$r.votes/stateData2006$total.votes)*stateData2006$seats
display <- stateData2006
seatsWonByState2006 <- dcast(seatsWonByState2006,state ~ parties,value.var="win",fill="0")
seatsWonByState2006$Democratic <- as.numeric(as.character(seatsWonByState2006$Democratic))
seatsWonByState2006$Republican <- as.numeric(as.character(seatsWonByState2006$Republican))
colnames(seatsWonByState2006)[2:3] <- c("act.D.seats","act.R.seats")
stateData2006 <- join(stateData2006,seatsWonByState2006,by="state",type="left")
stateData2006$voteratio <- ifelse(stateData2006$r.votes<stateData2006$d.votes,
                                  stateData2006$r.votes/stateData2006$d.votes,
                                  stateData2006$d.votes/stateData2006$r.votes)
stateData2006$majority <- ifelse(stateData2006$r.votes>stateData2006$d.votes,"R","D")

# efficiency gap by district
districtData2006 <- dcast(partyTotalsByDistrict2006,state + district + totalVote ~ parties,value.var="wastedVote",fill=0)
districtData2006$efficiency.gap <- abs(districtData2006$Democratic-districtData2006$Republican)/districtData2006$totalVote
districtData2006 <- districtData2006[,c("state","district","totalVote","Republican","Democratic","efficiency.gap")]
colnames(districtData2006)[4:5] <- c("w.votes.R","w.votes.D")
allPartyDistrictTotals2006 <- dcast(partyTotalsByDistrict2006,state + district ~ parties,value.var="votes",fill=0)
twoPartyDistrictTotals2006 <- allPartyDistrictTotals2006[,c("state","district","Republican","Democratic")]
colnames(twoPartyDistrictTotals2006)[3:4] <- c("votes.R","votes.D")
twoPartyDistrictTotals2006$vote.ratio <- ifelse(twoPartyDistrictTotals2006$votes.R<twoPartyDistrictTotals2006$votes.D,
                                                twoPartyDistrictTotals2006$votes.R/twoPartyDistrictTotals2006$votes.D,
                                                twoPartyDistrictTotals2006$votes.D/twoPartyDistrictTotals2006$votes.R)
districtData2006 <- join(districtData2006,twoPartyDistrictTotals2006,by=c("state","district"),type="left")
districtData2006$majority <- ifelse(districtData2006$votes.R>districtData2006$votes.D,"R","D")
districtData2006$margin <- (abs(districtData2006$votes.R-districtData2006$votes.D)/districtData2006$totalVote)*100
districtData2006$adv.R <- 0 
districtData2006$adv.D <- 0
for (i in 1:nrow(districtData2006)){
  if (districtData2006$w.votes.D[i] < districtData2006$w.votes.R[i]){
    districtData2006$adv.D[i] <- districtData2006$efficiency.gap[i]
  }
  else if (districtData2006$w.votes.R[i] < districtData2006$w.votes.D[i]){
    districtData2006$adv.R[i] <- districtData2006$efficiency.gap[i]
  }
}
sumAdv2006 <- aggregate(cbind(adv.R, adv.D) ~ state,districtData2006,sum)
sumAdv2006$state.seat.favor <- ifelse(sumAdv2006$adv.R>sumAdv2006$adv.D,"R","D")
sumAdv2006$state.seats.misapportioned <- abs(sumAdv2006$adv.R-sumAdv2006$adv.D)
sumAdv2006 <- sumAdv2006[,c(1,4,5)]
districtData2006 <- join(districtData2006,sumAdv2006,by="state",type="left")
# load 2008
results2008 <- "https://raw.githubusercontent.com/TimeMagazine/congressional-election-results/master/data/results_2008.csv"
# https://s3.amazonaws.com/s3.azavea.com/com.redistrictingthenation/pdfs/Redistricting_The_Nation_Addendum.pdf
cd2008 <- getURL(results2008)
cd2008 <- read.csv(textConnection(cd2008))
suppressWarnings(cd2008$votes <- as.numeric(as.character(cd2008$votes)))
cd2008 <- subset(cd2008,district != "S")
cd2008$district[cd2008$district == "01 - FULL TERM"] <- "01"
cd2008$district[cd2008$district == "04 - FULL TERM"] <- "04"
cd2008$district[cd2008$district == "10 - FULL TERM"] <- "10"
cd2008$district[cd2008$district == "11 - FULL TERM"] <- "11"
d <- c("Democratic,Working Families","Working Families,Democratic",
       "Democratic,Progressive,Working Families","Democratic-Farmer Labor",
       "Democratic,Working Families,Independence","Democratic,Independence,Working Families",
       "Democratic-Nonpartisan League","Write-In,Democratic,Democratic","Democratic")
r <- c("Republican,Tax Revolt,Conservative,Independence","Republican,Tax Revolt,Conservative",
       "Republican,Tax Revolt","Republican,Conservative","Conservative,Republican",
       "Republican,Conservative,Libertarian","Republican,Conservative,Independence",
       "Independence,Republican","Independent Party,Republican", "Republican,Constitution",
       "Write-In,Republican,Republican","Conservative,Independence,Republican","Republican")

for (i in 1:length(cd2008$parties)){
  if (cd2008$parties[i] %in% d){
    cd2008$parties[i] <- "Democratic"
  }
  else if (cd2008$parties[i] %in% r){
    cd2008$parties[i] <- "Republican"
  }
}
# calc total vote by state
totalVoteByState2008 <- aggregate(votes ~ state, cd2008, sum)
# calc total vote by district
totalVoteByDistrict2008 <- aggregate(votes ~ state + district, cd2008, sum)
totalVoteByDistrict2008 <- totalVoteByDistrict2008[order(totalVoteByDistrict2008$state,totalVoteByDistrict2008$district),]
# add threshold of simple majority based on each district's vote total
totalVoteByDistrict2008$simpleMajority <- round(totalVoteByDistrict2008$votes/2 + 1,0)
partyTotalsByDistrict2008 <- aggregate(votes ~ state + district + parties, cd2008, sum)
partyTotalsByDistrict2008 <- partyTotalsByDistrict2008[order(partyTotalsByDistrict2008$state,partyTotalsByDistrict2008$district),]
partyTotalsByDistrict2008 <- join(partyTotalsByDistrict2008,totalVoteByDistrict2008,by=c("state","district"),type="left")
colnames(partyTotalsByDistrict2008)[5] <- "totalVote"
partyTotalsByDistrict2008 <- partyTotalsByDistrict2008[,c(1,2,5,6,4,3)]
partyTotalsByDistrict2008$pctVote <- partyTotalsByDistrict2008$votes/partyTotalsByDistrict2008$totalVote

allStates <- unique(partyTotalsByDistrict2008$state)
allDistricts <- unique(partyTotalsByDistrict2008$district)
partyTotalsByDistrict2008$win <- 0 #create column to indicate wins

for (i in 1:length(allDistricts)){
  for (j in 1:length(allStates)){
    row_to_find <- data.frame(state=allStates[j], district=allDistricts[i])
    if(nrow(merge(row_to_find,partyTotalsByDistrict2008))>0){
      subFrame <- subset(partyTotalsByDistrict2008,state==allStates[j] & district==allDistricts[i])
      w <- which.max(subFrame$pctVote)
      partyTotalsByDistrict2008[partyTotalsByDistrict2008$state==allStates[j] & 
                                  partyTotalsByDistrict2008$district==allDistricts[i],]$win[w] <- 1
    }
  }
}
partyTotalsByDistrict2008$wastedVote <- 0
partyTotalsByDistrict2008$wastedVote <- ifelse(partyTotalsByDistrict2008$win == 1 & 
                                                 partyTotalsByDistrict2008$votes > partyTotalsByDistrict2008$simpleMajority,
                                               partyTotalsByDistrict2008$votes - partyTotalsByDistrict2008$simpleMajority,
                                               ifelse(partyTotalsByDistrict2008$win == 1,0,partyTotalsByDistrict2008$votes))
seatsWon2008 <- aggregate(win ~ parties,partyTotalsByDistrict2008,sum)
seatsWon2008 <- subset(seatsWon2008,win!=0)
seatsWonByState2008 <- aggregate(win ~ state + parties,partyTotalsByDistrict2008,sum)
seatsWonByState2008 <- subset(seatsWonByState2008,win!=0)
seatsWonByState2008 <- seatsWonByState2008[order(seatsWonByState2008$state,-seatsWonByState2008$win),]
totalWastedVoteByParty2008 <- aggregate(wastedVote ~ parties, partyTotalsByDistrict2008, sum)
totalWastedVoteByParty2008 <- totalWastedVoteByParty2008[order(-totalWastedVoteByParty2008$wastedVote),]
totalVoteByParty2008 <- aggregate(votes ~ parties, partyTotalsByDistrict2008, sum)
totalVoteByParty2008 <- totalVoteByParty2008[order(-totalVoteByParty2008$votes),]
numDistricts <- data.frame(table(totalVoteByDistrict2008$state))
colnames(numDistricts) <- c("state","number")
numDistricts[9,2] <- 27 # correct, missing two from redistricting
totalWastedVoteByPartyByState2008 <- aggregate(wastedVote ~ state + parties, partyTotalsByDistrict2008, sum)
totalVoteByPartyByState2008 <- aggregate(votes ~ state + parties, partyTotalsByDistrict2008, sum)
totalVoteByPartyByState2008 <- totalVoteByPartyByState2008[order(totalVoteByPartyByState2008$state,-totalVoteByPartyByState2008$votes),]
totalWastedVoteByPartyByState2008 <- totalWastedVoteByPartyByState2008[order(totalWastedVoteByPartyByState2008$state,-totalWastedVoteByPartyByState2008$wastedVote),]
stateData2008 <- subset(totalWastedVoteByPartyByState2008,parties=="Democratic" | totalWastedVoteByPartyByState2008$parties=="Republican")
stateData2008 <- dcast(stateData2008,state ~ parties,value.var="wastedVote")
# bind number districts and total vote
stateData2008 <- join(stateData2008,numDistricts,by="state",type="left")
stateData2008 <- join(stateData2008,totalVoteByState2008,by="state",type="left")
stateData2008$efficiency.gap <- abs(stateData2008$Democratic-stateData2008$Republican)/stateData2008$votes
stateData2008$seats.misapportioned <- stateData2008$efficiency.gap*stateData2008$number
colnames(stateData2008)[2:5] <- c("w.votes.D","w.votes.R","seats","total.votes")


totalVoteByPartyByState2008 <- subset(totalVoteByPartyByState2008,parties=="Democratic" | totalVoteByPartyByState2008$parties=="Republican")
totalVoteByPartyByState2008 <- dcast(totalVoteByPartyByState2008,state ~ parties,value.var="votes")
colnames(totalVoteByPartyByState2008)[2:3] <- c("d.votes","r.votes")
stateData2008 <- join(stateData2008,totalVoteByPartyByState2008,by="state",type="left")
# calculate projected seats
stateData2008$proj.D.seats <- (stateData2008$d.votes/stateData2008$total.votes)*stateData2008$seats
stateData2008$proj.R.seats <- (stateData2008$r.votes/stateData2008$total.votes)*stateData2008$seats
display <- stateData2008
seatsWonByState2008 <- dcast(seatsWonByState2008,state ~ parties,value.var="win",fill="0")
seatsWonByState2008$Democratic <- as.numeric(as.character(seatsWonByState2008$Democratic))
seatsWonByState2008$Republican <- as.numeric(as.character(seatsWonByState2008$Republican))
colnames(seatsWonByState2008)[2:3] <- c("act.D.seats","act.R.seats")
stateData2008 <- join(stateData2008,seatsWonByState2008,by="state",type="left")
stateData2008$voteratio <- ifelse(stateData2008$r.votes<stateData2008$d.votes,
                                  stateData2008$r.votes/stateData2008$d.votes,
                                  stateData2008$d.votes/stateData2008$r.votes)
stateData2008$majority <- ifelse(stateData2008$r.votes>stateData2008$d.votes,"R","D")

# efficiency gap by district
districtData2008 <- dcast(partyTotalsByDistrict2008,state + district + totalVote ~ parties,value.var="wastedVote",fill=0)
districtData2008$efficiency.gap <- abs(districtData2008$Democratic-districtData2008$Republican)/districtData2008$totalVote
districtData2008 <- districtData2008[,c("state","district","totalVote","Republican","Democratic","efficiency.gap")]
colnames(districtData2008)[4:5] <- c("w.votes.R","w.votes.D")
allPartyDistrictTotals2008 <- dcast(partyTotalsByDistrict2008,state + district ~ parties,value.var="votes",fill=0)
twoPartyDistrictTotals2008 <- allPartyDistrictTotals2008[,c("state","district","Republican","Democratic")]
colnames(twoPartyDistrictTotals2008)[3:4] <- c("votes.R","votes.D")
twoPartyDistrictTotals2008$vote.ratio <- ifelse(twoPartyDistrictTotals2008$votes.R<twoPartyDistrictTotals2008$votes.D,
                                                twoPartyDistrictTotals2008$votes.R/twoPartyDistrictTotals2008$votes.D,
                                                twoPartyDistrictTotals2008$votes.D/twoPartyDistrictTotals2008$votes.R)
districtData2008 <- join(districtData2008,twoPartyDistrictTotals2008,by=c("state","district"),type="left")
districtData2008$majority <- ifelse(districtData2008$votes.R>districtData2008$votes.D,"R","D")
districtData2008$margin <- (abs(districtData2008$votes.R-districtData2008$votes.D)/districtData2008$totalVote)*100
districtData2008$adv.R <- 0 
districtData2008$adv.D <- 0
for (i in 1:nrow(districtData2008)){
  if (districtData2008$w.votes.D[i] < districtData2008$w.votes.R[i]){
    districtData2008$adv.D[i] <- districtData2008$efficiency.gap[i]
  }
  else if (districtData2008$w.votes.R[i] < districtData2008$w.votes.D[i]){
    districtData2008$adv.R[i] <- districtData2008$efficiency.gap[i]
  }
}
sumAdv2008 <- aggregate(cbind(adv.R, adv.D) ~ state,districtData2008,sum)
sumAdv2008$state.seat.favor <- ifelse(sumAdv2008$adv.R>sumAdv2008$adv.D,"R","D")
sumAdv2008$state.seats.misapportioned <- abs(sumAdv2008$adv.R-sumAdv2008$adv.D)
sumAdv2008 <- sumAdv2008[,c(1,4,5)]
districtData2008 <- join(districtData2008,sumAdv2008,by="state",type="left")
#load 2010
results2010 <- "https://raw.githubusercontent.com/TimeMagazine/congressional-election-results/master/data/results_2010.csv"
# https://s3.amazonaws.com/s3.azavea.com/com.redistrictingthenation/pdfs/Redistricting_The_Nation_Addendum.pdf
cd2010 <- getURL(results2010)
cd2010 <- read.csv(textConnection(cd2010))
suppressWarnings(cd2010$votes <- as.numeric(as.character(cd2010$votes)))
cd2010 <- subset(cd2010,district != "S")
cd2010$district[cd2010$district == "01 - FULL TERM"] <- "01"
cd2010$district[cd2010$district == "04 - FULL TERM"] <- "04"
cd2010$district[cd2010$district == "10 - FULL TERM"] <- "10"
cd2010$district[cd2010$district == "11 - FULL TERM"] <- "11"
d <- c("Democratic,Working Families","Working Families,Democratic",
       "Democratic,Progressive,Working Families","Democratic-Farmer Labor",
       "Democratic,Working Families,Independence","Democratic,Independence,Working Families",
       "Democratic-Nonpartisan League","Write-In,Democratic,Democratic","Democratic")
r <- c("Republican,Tax Revolt,Conservative,Independence","Republican,Tax Revolt,Conservative",
       "Republican,Tax Revolt","Republican,Conservative","Conservative,Republican",
       "Republican,Conservative,Libertarian","Republican,Conservative,Independence",
       "Independence,Republican","Independent Party,Republican", "Republican,Constitution",
       "Write-In,Republican,Republican","Conservative,Independence,Republican","Republican")

for (i in 1:length(cd2010$parties)){
  if (cd2010$parties[i] %in% d){
    cd2010$parties[i] <- "Democratic"
  }
  else if (cd2010$parties[i] %in% r){
    cd2010$parties[i] <- "Republican"
  }
}
# calc total vote by state
totalVoteByState2010 <- aggregate(votes ~ state, cd2010, sum)
# calc total vote by district
totalVoteByDistrict2010 <- aggregate(votes ~ state + district, cd2010, sum)
totalVoteByDistrict2010 <- totalVoteByDistrict2010[order(totalVoteByDistrict2010$state,totalVoteByDistrict2010$district),]
# add threshold of simple majority based on each district's vote total
totalVoteByDistrict2010$simpleMajority <- round(totalVoteByDistrict2010$votes/2 + 1,0)
partyTotalsByDistrict2010 <- aggregate(votes ~ state + district + parties, cd2010, sum)
partyTotalsByDistrict2010 <- partyTotalsByDistrict2010[order(partyTotalsByDistrict2010$state,partyTotalsByDistrict2010$district),]
partyTotalsByDistrict2010 <- join(partyTotalsByDistrict2010,totalVoteByDistrict2010,by=c("state","district"),type="left")
colnames(partyTotalsByDistrict2010)[5] <- "totalVote"
partyTotalsByDistrict2010 <- partyTotalsByDistrict2010[,c(1,2,5,6,4,3)]
partyTotalsByDistrict2010$pctVote <- partyTotalsByDistrict2010$votes/partyTotalsByDistrict2010$totalVote

allStates <- unique(partyTotalsByDistrict2010$state)
allDistricts <- unique(partyTotalsByDistrict2010$district)
partyTotalsByDistrict2010$win <- 0 #create column to indicate wins

for (i in 1:length(allDistricts)){
  for (j in 1:length(allStates)){
    row_to_find <- data.frame(state=allStates[j], district=allDistricts[i])
    if(nrow(merge(row_to_find,partyTotalsByDistrict2010))>0){
      subFrame <- subset(partyTotalsByDistrict2010,state==allStates[j] & district==allDistricts[i])
      w <- which.max(subFrame$pctVote)
      partyTotalsByDistrict2010[partyTotalsByDistrict2010$state==allStates[j] & 
                                  partyTotalsByDistrict2010$district==allDistricts[i],]$win[w] <- 1
    }
  }
}
partyTotalsByDistrict2010$wastedVote <- 0
partyTotalsByDistrict2010$wastedVote <- ifelse(partyTotalsByDistrict2010$win == 1 & 
                                                 partyTotalsByDistrict2010$votes > partyTotalsByDistrict2010$simpleMajority,
                                               partyTotalsByDistrict2010$votes - partyTotalsByDistrict2010$simpleMajority,
                                               ifelse(partyTotalsByDistrict2010$win == 1,0,partyTotalsByDistrict2010$votes))
seatsWon2010 <- aggregate(win ~ parties,partyTotalsByDistrict2010,sum)
seatsWon2010 <- subset(seatsWon2010,win!=0)
seatsWonByState2010 <- aggregate(win ~ state + parties,partyTotalsByDistrict2010,sum)
seatsWonByState2010 <- subset(seatsWonByState2010,win!=0)
seatsWonByState2010 <- seatsWonByState2010[order(seatsWonByState2010$state,-seatsWonByState2010$win),]
totalWastedVoteByParty2010 <- aggregate(wastedVote ~ parties, partyTotalsByDistrict2010, sum)
totalWastedVoteByParty2010 <- totalWastedVoteByParty2010[order(-totalWastedVoteByParty2010$wastedVote),]
totalVoteByParty2010 <- aggregate(votes ~ parties, partyTotalsByDistrict2010, sum)
totalVoteByParty2010 <- totalVoteByParty2010[order(-totalVoteByParty2010$votes),]
numDistricts <- data.frame(table(totalVoteByDistrict2010$state))
colnames(numDistricts) <- c("state","number")
numDistricts[9,2] <- 27 # correct, missing two from redistricting
totalWastedVoteByPartyByState2010 <- aggregate(wastedVote ~ state + parties, partyTotalsByDistrict2010, sum)
totalVoteByPartyByState2010 <- aggregate(votes ~ state + parties, partyTotalsByDistrict2010, sum)
totalVoteByPartyByState2010 <- totalVoteByPartyByState2010[order(totalVoteByPartyByState2010$state,-totalVoteByPartyByState2010$votes),]
totalWastedVoteByPartyByState2010 <- totalWastedVoteByPartyByState2010[order(totalWastedVoteByPartyByState2010$state,-totalWastedVoteByPartyByState2010$wastedVote),]
stateData2010 <- subset(totalWastedVoteByPartyByState2010,parties=="Democratic" | totalWastedVoteByPartyByState2010$parties=="Republican")
stateData2010 <- dcast(stateData2010,state ~ parties,value.var="wastedVote")
# bind number districts and total vote
stateData2010 <- join(stateData2010,numDistricts,by="state",type="left")
stateData2010 <- join(stateData2010,totalVoteByState2010,by="state",type="left")
stateData2010$efficiency.gap <- abs(stateData2010$Democratic-stateData2010$Republican)/stateData2010$votes
stateData2010$seats.misapportioned <- stateData2010$efficiency.gap*stateData2010$number
colnames(stateData2010)[2:5] <- c("w.votes.D","w.votes.R","seats","total.votes")
totalVoteByPartyByState2010 <- subset(totalVoteByPartyByState2010,parties=="Democratic" | totalVoteByPartyByState2010$parties=="Republican")
totalVoteByPartyByState2010 <- dcast(totalVoteByPartyByState2010,state ~ parties,value.var="votes")
colnames(totalVoteByPartyByState2010)[2:3] <- c("d.votes","r.votes")
stateData2010 <- join(stateData2010,totalVoteByPartyByState2010,by="state",type="left")
# calculate projected seats
stateData2010$proj.D.seats <- (stateData2010$d.votes/stateData2010$total.votes)*stateData2010$seats
stateData2010$proj.R.seats <- (stateData2010$r.votes/stateData2010$total.votes)*stateData2010$seats
display <- stateData2010
seatsWonByState2010 <- dcast(seatsWonByState2010,state ~ parties,value.var="win",fill="0")
seatsWonByState2010$Democratic <- as.numeric(as.character(seatsWonByState2010$Democratic))
seatsWonByState2010$Republican <- as.numeric(as.character(seatsWonByState2010$Republican))
colnames(seatsWonByState2010)[2:3] <- c("act.D.seats","act.R.seats")
stateData2010 <- join(stateData2010,seatsWonByState2010,by="state",type="left")
stateData2010$voteratio <- ifelse(stateData2010$r.votes<stateData2010$d.votes,
                                  stateData2010$r.votes/stateData2010$d.votes,
                                  stateData2010$d.votes/stateData2010$r.votes)
stateData2010$majority <- ifelse(stateData2010$r.votes>stateData2010$d.votes,"R","D")

# efficiency gap by district
districtData2010 <- dcast(partyTotalsByDistrict2010,state + district + totalVote ~ parties,value.var="wastedVote",fill=0)
districtData2010$efficiency.gap <- abs(districtData2010$Democratic-districtData2010$Republican)/districtData2010$totalVote
districtData2010 <- districtData2010[,c("state","district","totalVote","Republican","Democratic","efficiency.gap")]
colnames(districtData2010)[4:5] <- c("w.votes.R","w.votes.D")
allPartyDistrictTotals2010 <- dcast(partyTotalsByDistrict2010,state + district ~ parties,value.var="votes",fill=0)
twoPartyDistrictTotals2010 <- allPartyDistrictTotals2010[,c("state","district","Republican","Democratic")]
colnames(twoPartyDistrictTotals2010)[3:4] <- c("votes.R","votes.D")
twoPartyDistrictTotals2010$vote.ratio <- ifelse(twoPartyDistrictTotals2010$votes.R<twoPartyDistrictTotals2010$votes.D,
                                                twoPartyDistrictTotals2010$votes.R/twoPartyDistrictTotals2010$votes.D,
                                                twoPartyDistrictTotals2010$votes.D/twoPartyDistrictTotals2010$votes.R)
districtData2010 <- join(districtData2010,twoPartyDistrictTotals2010,by=c("state","district"),type="left")
districtData2010$majority <- ifelse(districtData2010$votes.R>districtData2010$votes.D,"R","D")
districtData2010$margin <- (abs(districtData2010$votes.R-districtData2010$votes.D)/districtData2010$totalVote)*100
districtData2010$adv.R <- 0 
districtData2010$adv.D <- 0
for (i in 1:nrow(districtData2010)){
  if (districtData2010$w.votes.D[i] < districtData2010$w.votes.R[i]){
    districtData2010$adv.D[i] <- districtData2010$efficiency.gap[i]
  }
  else if (districtData2010$w.votes.R[i] < districtData2010$w.votes.D[i]){
    districtData2010$adv.R[i] <- districtData2010$efficiency.gap[i]
  }
}
sumAdv2010 <- aggregate(cbind(adv.R, adv.D) ~ state,districtData2010,sum)
sumAdv2010$state.seat.favor <- ifelse(sumAdv2010$adv.R>sumAdv2010$adv.D,"R","D")
sumAdv2010$state.seats.misapportioned <- abs(sumAdv2010$adv.R-sumAdv2010$adv.D)
sumAdv2010 <- sumAdv2010[,c(1,4,5)]
districtData2010 <- join(districtData2010,sumAdv2010,by="state",type="left")
# load 2012
results2012 <- "https://raw.githubusercontent.com/TimeMagazine/congressional-election-results/master/data/results_2012.csv"
# https://s3.amazonaws.com/s3.azavea.com/com.redistrictingthenation/pdfs/Redistricting_The_Nation_Addendum.pdf
cd2012 <- getURL(results2012)
cd2012 <- read.csv(textConnection(cd2012))
suppressWarnings(cd2012$votes <- as.numeric(as.character(cd2012$votes)))
cd2012 <- subset(cd2012,district != "S")
cd2012$district[cd2012$district == "01 - FULL TERM"] <- "01"
cd2012$district[cd2012$district == "04 - FULL TERM"] <- "04"
cd2012$district[cd2012$district == "10 - FULL TERM"] <- "10"
cd2012$district[cd2012$district == "11 - FULL TERM"] <- "11"
d <- c("Democratic,Working Families","Working Families,Democratic",
       "Democratic,Progressive,Working Families","Democratic-Farmer Labor",
       "Democratic,Working Families,Independence","Democratic,Independence,Working Families",
       "Democratic-Nonpartisan League","Write-In,Democratic,Democratic","Democratic")
r <- c("Republican,Tax Revolt,Conservative,Independence","Republican,Tax Revolt,Conservative",
       "Republican,Tax Revolt","Republican,Conservative","Conservative,Republican",
       "Republican,Conservative,Libertarian","Republican,Conservative,Independence",
       "Independence,Republican","Independent Party,Republican", "Republican,Constitution",
       "Write-In,Republican,Republican","Conservative,Independence,Republican","Republican")

for (i in 1:length(cd2012$parties)){
  if (cd2012$parties[i] %in% d){
    cd2012$parties[i] <- "Democratic"
  }
  else if (cd2012$parties[i] %in% r){
    cd2012$parties[i] <- "Republican"
  }
}
# calc total vote by state
totalVoteByState2012 <- aggregate(votes ~ state, cd2012, sum)
# calc total vote by district
totalVoteByDistrict2012 <- aggregate(votes ~ state + district, cd2012, sum)
totalVoteByDistrict2012 <- totalVoteByDistrict2012[order(totalVoteByDistrict2012$state,totalVoteByDistrict2012$district),]
# add threshold of simple majority based on each district's vote total
totalVoteByDistrict2012$simpleMajority <- round(totalVoteByDistrict2012$votes/2 + 1,0)
partyTotalsByDistrict2012 <- aggregate(votes ~ state + district + parties, cd2012, sum)
partyTotalsByDistrict2012 <- partyTotalsByDistrict2012[order(partyTotalsByDistrict2012$state,partyTotalsByDistrict2012$district),]
partyTotalsByDistrict2012 <- join(partyTotalsByDistrict2012,totalVoteByDistrict2012,by=c("state","district"),type="left")
colnames(partyTotalsByDistrict2012)[5] <- "totalVote"
partyTotalsByDistrict2012 <- partyTotalsByDistrict2012[,c(1,2,5,6,4,3)]
partyTotalsByDistrict2012$pctVote <- partyTotalsByDistrict2012$votes/partyTotalsByDistrict2012$totalVote

allStates <- unique(partyTotalsByDistrict2012$state)
allDistricts <- unique(partyTotalsByDistrict2012$district)
partyTotalsByDistrict2012$win <- 0 #create column to indicate wins

for (i in 1:length(allDistricts)){
  for (j in 1:length(allStates)){
    row_to_find <- data.frame(state=allStates[j], district=allDistricts[i])
    if(nrow(merge(row_to_find,partyTotalsByDistrict2012))>0){
      subFrame <- subset(partyTotalsByDistrict2012,state==allStates[j] & district==allDistricts[i])
      w <- which.max(subFrame$pctVote)
      partyTotalsByDistrict2012[partyTotalsByDistrict2012$state==allStates[j] & 
      partyTotalsByDistrict2012$district==allDistricts[i],]$win[w] <- 1
    }
  }
}
partyTotalsByDistrict2012$wastedVote <- 0
partyTotalsByDistrict2012$wastedVote <- ifelse(partyTotalsByDistrict2012$win == 1 & 
                                     partyTotalsByDistrict2012$votes > partyTotalsByDistrict2012$simpleMajority,
                                   partyTotalsByDistrict2012$votes - partyTotalsByDistrict2012$simpleMajority,
                                   ifelse(partyTotalsByDistrict2012$win == 1,0,partyTotalsByDistrict2012$votes))
seatsWon2012 <- aggregate(win ~ parties,partyTotalsByDistrict2012,sum)
seatsWon2012 <- subset(seatsWon2012,win!=0)
seatsWonByState2012 <- aggregate(win ~ state + parties,partyTotalsByDistrict2012,sum)
seatsWonByState2012 <- subset(seatsWonByState2012,win!=0)
seatsWonByState2012 <- seatsWonByState2012[order(seatsWonByState2012$state,-seatsWonByState2012$win),]
totalWastedVoteByParty2012 <- aggregate(wastedVote ~ parties, partyTotalsByDistrict2012, sum)
totalWastedVoteByParty2012 <- totalWastedVoteByParty2012[order(-totalWastedVoteByParty2012$wastedVote),]
totalVoteByParty2012 <- aggregate(votes ~ parties, partyTotalsByDistrict2012, sum)
totalVoteByParty2012 <- totalVoteByParty2012[order(-totalVoteByParty2012$votes),]
numDistricts <- data.frame(table(totalVoteByDistrict2012$state))
colnames(numDistricts) <- c("state","number")
numDistricts[9,2] <- 27 # correct, missing two from redistricting
totalWastedVoteByPartyByState2012 <- aggregate(wastedVote ~ state + parties, partyTotalsByDistrict2012, sum)
totalVoteByPartyByState2012 <- aggregate(votes ~ state + parties, partyTotalsByDistrict2012, sum)
totalVoteByPartyByState2012 <- totalVoteByPartyByState2012[order(totalVoteByPartyByState2012$state,-totalVoteByPartyByState2012$votes),]
totalWastedVoteByPartyByState2012 <- totalWastedVoteByPartyByState2012[order(totalWastedVoteByPartyByState2012$state,-totalWastedVoteByPartyByState2012$wastedVote),]
stateData2012 <- subset(totalWastedVoteByPartyByState2012,parties=="Democratic" | totalWastedVoteByPartyByState2012$parties=="Republican")
stateData2012 <- dcast(stateData2012,state ~ parties,value.var="wastedVote")
# bind number districts and total vote
stateData2012 <- join(stateData2012,numDistricts,by="state",type="left")
stateData2012 <- join(stateData2012,totalVoteByState2012,by="state",type="left")
stateData2012$efficiency.gap <- abs(stateData2012$Democratic-stateData2012$Republican)/stateData2012$votes
stateData2012$seats.misapportioned <- stateData2012$efficiency.gap*stateData2012$number
colnames(stateData2012)[2:5] <- c("w.votes.D","w.votes.R","seats","total.votes")
stateData2012$adv.R <- 0 
stateData2012$adv.D <- 0

for (i in 1:nrow(stateData2012)){
  if (stateData2012$w.votes.D[i] < stateData2012$w.votes.R[i]){
    stateData2012$adv.D[i] <- stateData2012$seats.misapportioned[i]
  }
  else if (stateData2012$w.votes.R[i] < stateData2012$w.votes.D[i]){
    stateData2012$adv.R[i] <- stateData2012$seats.misapportioned[i]
  }
}
totalVoteByPartyByState2012 <- subset(totalVoteByPartyByState2012,parties=="Democratic" | totalVoteByPartyByState2012$parties=="Republican")
totalVoteByPartyByState2012 <- dcast(totalVoteByPartyByState2012,state ~ parties,value.var="votes")
colnames(totalVoteByPartyByState2012)[2:3] <- c("d.votes","r.votes")
stateData2012 <- join(stateData2012,totalVoteByPartyByState2012,by="state",type="left")
# calculate projected seats
stateData2012$proj.D.seats <- (stateData2012$d.votes/stateData2012$total.votes)*stateData2012$seats
stateData2012$proj.R.seats <- (stateData2012$r.votes/stateData2012$total.votes)*stateData2012$seats
display <- stateData2012
seatsWonByState2012 <- dcast(seatsWonByState2012,state ~ parties,value.var="win",fill="0")
seatsWonByState2012$Democratic <- as.numeric(as.character(seatsWonByState2012$Democratic))
seatsWonByState2012$Republican <- as.numeric(as.character(seatsWonByState2012$Republican))
colnames(seatsWonByState2012)[2:3] <- c("act.D.seats","act.R.seats")
stateData2012 <- join(stateData2012,seatsWonByState2012,by="state",type="left")
stateData2012$voteratio <- ifelse(stateData2012$r.votes<stateData2012$d.votes,
                          stateData2012$r.votes/stateData2012$d.votes,
                          stateData2012$d.votes/stateData2012$r.votes)
stateData2012$majority <- ifelse(stateData2012$r.votes>stateData2012$d.votes,"R","D")

# efficiency gap by district
districtData2012 <- dcast(partyTotalsByDistrict2012,state + district + totalVote ~ parties,value.var="wastedVote",fill=0)
districtData2012$efficiency.gap <- abs(districtData2012$Democratic-districtData2012$Republican)/districtData2012$totalVote
districtData2012 <- districtData2012[,c("state","district","totalVote","Republican","Democratic","efficiency.gap")]
colnames(districtData2012)[4:5] <- c("w.votes.R","w.votes.D")
allPartyDistrictTotals2012 <- dcast(partyTotalsByDistrict2012,state + district ~ parties,value.var="votes",fill=0)
twoPartyDistrictTotals2012 <- allPartyDistrictTotals2012[,c("state","district","Republican","Democratic")]
colnames(twoPartyDistrictTotals2012)[3:4] <- c("votes.R","votes.D")
twoPartyDistrictTotals2012$vote.ratio <- ifelse(twoPartyDistrictTotals2012$votes.R<twoPartyDistrictTotals2012$votes.D,
                                                twoPartyDistrictTotals2012$votes.R/twoPartyDistrictTotals2012$votes.D,
                                                twoPartyDistrictTotals2012$votes.D/twoPartyDistrictTotals2012$votes.R)
districtData2012 <- join(districtData2012,twoPartyDistrictTotals2012,by=c("state","district"),type="left")
districtData2012$majority <- ifelse(districtData2012$votes.R>districtData2012$votes.D,"R","D")
districtData2012$margin <- (abs(districtData2012$votes.R-districtData2012$votes.D)/districtData2012$totalVote)*100
districtData2012$adv.R <- 0 
districtData2012$adv.D <- 0
for (i in 1:nrow(districtData2012)){
  if (districtData2012$w.votes.D[i] < districtData2012$w.votes.R[i]){
    districtData2012$adv.D[i] <- districtData2012$efficiency.gap[i]
  }
  else if (districtData2012$w.votes.R[i] < districtData2012$w.votes.D[i]){
    districtData2012$adv.R[i] <- districtData2012$efficiency.gap[i]
  }
}
sumAdv2012 <- aggregate(cbind(adv.R, adv.D) ~ state,districtData2012,sum)
sumAdv2012$state.seat.favor <- ifelse(sumAdv2012$adv.R>sumAdv2012$adv.D,"R","D")
sumAdv2012$state.seats.misapportioned <- abs(sumAdv2012$adv.R-sumAdv2012$adv.D)
sumAdv2012 <- sumAdv2012[,c(1,4,5)]
districtData2012 <- join(districtData2012,sumAdv2012,by="state",type="left")
```

### Introduction

The practice of gerrymandering has long cast a shadow over electoral politics in the United States. The US Constitution relegates the power to draw the boundaries of congressional districts to the states, and in most cases – 42, to be precise – this falls primarily to the state legislature. With the ability to shift geographical lines between their state’s federal congressional districts, state legislators have enormous power to entrench their party’s political base, diminish their opposition, and effectively disenfranchise minority votes.

Identifying extreme cases of gerrymandering is not difficult. Most casual observers could look at a map and quickly identify North Carolina’s 12th or Illinois’s 4th congressional district as long, narrow, meandering attempts to influence demographic representation. Both are cases of packing demographic minorities into districts where they wield the majority, thereby decreasing their influence in other districts. This tactic, referred to as packing, can be employed alone or in conjunction with cracking, where a demographic or partisan minority is spread among all of the congressional districts, guaranteeing victories for the majority in every district, but also maintaining a thin margin of victory that puts those seats at risk with smaller changes in voter behavior. As an example: Party A holds a 55% majority across a state apportioned five districts. Party B holds 45% of the vote. Party A can divide the districts uniformly so they win all five seats by a ten-point margin. This guarantees them all of the seats, but puts each of the congressional representatives in somewhat competitive seats. Alternatively, they can pack as many Party B voters into one congressional district, guaranteeing party B one safe, non-competitive seat and Party A the other four. Both outcomes are less equitable than a system of guaranteed proportional representation where the minority party would hold two of the five seats.

### Measures of Geometric Compactness

Despite the influence gerrymandering has had on the political system, there are few measures that accurately capture the extent to which it diminishes partisan competition and representation of particular demographics. Common methods of measuring gerrymandering use a district’s geometric compactness as a proxy. A brief overview of how these methods measure the irregularity of a district:

*Polsby-Popper Method*: The ratio of the district’s area to the area of a circle with the same perimeter. A district can range from 0 to 1, with lower values indicating lesser compactness and greater gerrymandering. 

*Reock Test*: Similar to the Polsby-Popper method, the Reock test measures compactness by the ratio of a district area to the area of the smallest circle that can completely enclose the district geometrically.

*Convex Hull*: Compares the area of a district to the area of the smallest convex polygon that can enclose it.

*Schwartzberg*: Similar to the Polsby-Popper method, the Schwartzberg measure takes the ratio of the perimeter of a district to the area of a circle with the same perimeter.  

These methods can be useful indicators of gerrymandering in some cases, but there are significant drawbacks to measures of geometric compactness. One is that the shapes of states are highly irregular and that may reflect development patterns. Article 1, Section 2 of the U.S. Constitution requires that states create districts with roughly equal population (see: [Wesberry v. Sanders, 1964](https://scholar.google.com/scholar_case?case=6357954371173516293)).  Given urban and rural settlement patterns, it is easy to see how irregular districts arise when optimizing for population distribution and geometric compactness. If we try to divide Idaho’s two congressional districts evenly between its population and also optimize for the geometric compactness of the two, we see that there’s no ideal solution. In some geometric patterns, it also may not be possible to increase the compactness of one district without decreasing the compactness of the adjacent district. Optimizing for all of these constraints doesn’t always provide a neat solution, so the results may not always be indicative of gerrymandering. 
	      
Two of these measures, Polsby Popper and Schwartzberg, are very sensitive to the perimeter of a district, even when borders are affected by natural boundaries such as rivers, mountain ranges, and coastlines. The coastal districts in Maryland, Virginia, and North Carolina register very high on these indices. These measures also fail to help us understand gerrymandering patterns within a state. Does the difference in geometric density between the neat polygons of Western Massachusetts and Cape Cod reveal partisan gerrymandering or is it simply an accident of geography? And how do we account for differences between the shapes of the Plains States and those on the Atlantic Coast? These indices can be of some help in identifying egregious cases of partisan meddling - North Carolina’s 12th district - but there’s been little effort to correct for the likelihood of misclassification. Overall, these methods fail to explain patterns within a state as well as account for geometric differences between states.

### Defining a Metric for Misapportionment

A greater flaw to the general approach of compactness measures is that they do not serve as indicators of misapportionment across party lines and therefore cannot be used in courts of law by plaintiffs who attempt to litigate the most egregious cases of gerrymandering. In a *University of Chicago Law Review* article published in 2014, Nicholas Stephanopoulos and Eric McGhee suggest that the Supreme Court may consider measures of partisan intent in assessing the constitutionality of some gerrymandering.  They measure gerrymandering by calculating an efficiency gap for a given state’s congressional districts. The efficiency gap is measured by the difference in each party’s wasted votes – those votes in excess of the simple majority in districts a party won and all of the votes in districts that it lost. The gap is then measured by the difference in the two parties’ wasted votes in the state and divided by the total number of voters.  Stephanopoulos provides an example in an article he wrote in *The New Republic*:

> Suppose, for example, that a state has five districts with 100 voters each, and two parties, Party A and Party
> B. Suppose also that Party A wins four of the seats 53 to 47, and Party B wins one of them 85 to 15. Then in
> each of the four seats that Party A wins, it has 2 surplus votes (53 minus the 51 needed to win), and Party B
> has 47 lost votes. And in the lone district that Party A loses, it has 15 lost votes, and Party B has 34
> surplus votes (85 minus the 51 needed to win). In sum, Party A wastes 23 votes and Party B wastes 222 votes.
> Subtracting one figure from the other and dividing by the 500 votes cast produces an efficiency gap of 40% in
> Party A’s favor.

To better illustrate the example, we can look at a table of the results. Here the efficiency gap is:

$$EG = \frac{abs(Party\:A\:Wasted\:Votes-Party\:B\:Wasted\:Votes)}{Total\:Votes} = 0.398$$

```{r,echo=FALSE}
ex <- data.frame(District=c(1:5),A.Votes=c(53,53,53,53,15),B.Votes=c(47,47,47,47,85),A.Wasted.Votes=c(2,2,2,2,15),B.Wasted.Votes=c(47,47,47,47,85),Winner=c("A","A","A","A","B"))
kable(ex)
```

Stephanopoulos and McGhee extend this measure to calculate the number of misapportioned congressional seats in a state by taking the product of the efficiency gap and the number of districts, with the belief that that courts should then hold states’ districting to a maximum of two misapportioned seats. Since this approach provides a consistent metric for identify partisan gerrymandering between states, we will refer to it in this paper as the $\textit{Statewide\:Efficiency\:Gap}$. The approach also extends nicely to calculate a national aggregate of misapportioned seats. It is limited, however, in its ability identifying gerrymandered districts and patterns within states.

Arithmetically, we can consider the efficiency gap in a single district as the difference in the portion of a seat that the wasted votes should control if there was perfect partisan symmetry (where a vote for one party has equal power as a vote for another). 

Here is an example of a district with the wasted votes for each party: 

Party         |  Votes         | Wasted Votes
------------- |  ------------- | -------------
Republican    | 300            | 300
Democratic    | 700            | 199

Every Republican vote and each Democratic vote in excess of a simple majority is considered “wasted”. The efficiency gap in this district is the difference in wasted votes divided by the vote total: $0.101$. We then consider this value of the efficiency gap as an advantage to the Democrats. It is the proportion of a seat they hold based on the asymmetric power of a Democratic vote over a Republican vote. If a state contained ten identical districts, then the Democrats would hold all ten seats and we would compare the aggregate advantage for each party and determine that about one seat is misapportioned in the Democrats' favor. This may counter our intuitive sense of fairness, since it seems Republicans should probably win three out of ten fairly drawn districts, but the point of identifying misapportionment in this way is to align methods with legal bases for combatting partisan gerrymandering. The system of apportionment isn’t designed to be perfectly proportional between parties, but to provide equal voting power to individuals. In our theoretical state where the Republicans are cracked into ten 70:30 minorities, we must also consider that the gerrymandering strategy dilutes the power of Democratic voters, who also lose a degree of influence in the voting process since their representatives have very safe majorities. This has effects on accountability and entrenchment, which are less tangible, but are captured by our measure of inefficiency. 

My metric for misapportionment is the $\textit{District\:Efficiency\:Gap}$ and is an adaptation of the Statewide Efficiency Gap described above. I will use the same method to calculate the wasted vote for the two major parties in each district. Rather than aggregating the wasted vote by each party in each state, I will calculate the efficiency gap for each congressional district, and then sum these district efficiency gaps for each party in each state. We will consider the difference between the two parties as seat misapportionment in favor of the party with the larger aggregate gap: either “Advantage Republican” or “Advantage Democrat”.

$$District\:EG = \frac{abs(A\:Wasted\:Votes-B\:Wasted\:Votes)}{Total\:Votes}$$
$$For\:a\:given\:state:$$
$$If\:\sum EG_{D} = \sum EG_{R},$$
$$Then\:there\:is\:partisan\:symmetry$$
$$Else\:If\:\sum EG_{D} > \sum EG_{R},$$
$$Advantage\:Democrat = \sum EG_{D} - \sum EG_{R}$$
$$Else\:If\:\sum EG_{R} > \sum EG_{D},$$
$$Advantage\:Republican = \sum EG_{R} - \sum EG_{D}$$

\newpage  

We can apply this to a theoretical state:

District      |  R Votes | D Votes | R Wasted Votes | D Wasted Votes | EG    | Majority
------------- |  ------  | ------- | -------------  | -------------  | ----- | -----
1             | 450      | 550     | 450            | 49             | 0.401 | D
2             | 200      | 800     | 200            | 299            | 0.099 | D
3             | 750      | 250     | 249            | 250            | 0.001 | R
4             | 295      | 705     | 295            | 204            | 0.091 | D
5             | 300      | 700     | 300            | 199            | 0.101 | D

Here we have a state with five districts and 5,000 voters. Republicans have exactly 39.9% of the vote but hold only one of the five seats. In a proportional system, they would win two seats. If we sum the efficiency gaps by district winners, the Republican advantage is 0.001 and the Democratic advantage is 0.692. By taking the difference, we get a misapportionment of 0.691 seats in favor of the Democrats. Since seats aren't divisible, we should round the misapportionment to the nearest whole number. If the seat misapportionment for a state is less than 0.5, we should consider zero seats to be misapportioned. In this case, we should round up and consider one seat to be misapportioned. This improves upon the Statewide Efficiency Gap since it is more sensitive to seat misapportionment. If we summed the wasted votes by party for this example, we would get 1494 for the Republicans and 1001 for the Democrats. This would give us:

$$Statewide\:EG = \frac{abs(A\:Wasted\:Votes-B\:Wasted\:Votes)}{Total\:Votes} = 0.0986$$
$$Seat\:Misapportionment =\:Statewide\:EG\times\:Seats = 0.493$$ 

In this case, the statewide efficiency gap rould fail to identify a misapportioned seat! I believe the district efficiency gap provides a clearer link to gerrymandering strategy since it gives us a tool to analyze patterns within a state as the majority party attempts to maximize the difference in the two parties' advantages. No district should be considered gerrymandered in isolation. The efforts of a majority party to alter the partisan composition of one district naturally affects the composition of the others. We can use the district efficiency gap to identify cases where the majority party is maximizing the efficiency of their votes while minimizing the efficiency of their opponents'. Looking at the table above, it is easy to identify how the Democrats gerrymandered a seat in their favor. The Republicans are packed into the 3rd district where the efficiency gap is minimized and the Democrats cracked the rest of the districts, gaining modest advantages in safe districts (the 2nd, 4th, 5th) and a significant advantage in a competitive district (the 1st).

In order to understand how the efficiency gap responds as a function of the vote ratio, I created a theoretical district with 101 voters and two parties and calculated the efficiency gap and vote ratio for every possible outcome. The vote ratio is simply the votes for minority party over the votes for the majority party. If the Republican party wins a district with a $0.5$ vote ratio, then they outnumber Democratic voters 2:1. The plot below shows that the vote ratio ranges from $0 \leq VR \leq 1$ and the efficiency gap ranges from $0 \leq EG \leq 0.5$. 

```{r,echo=FALSE}
sim <- data.frame(a=1:100,b=100:1)
sim$wasted.b <- ifelse(sim$b>50,sim$b-50,sim$b)
sim$wasted.a <- ifelse(sim$a>50,sim$a-50,sim$a)
sim$margin <- abs(sim$a-sim$b)
sim$vote.ratio <- ifelse(sim$a<sim$b,sim$a/sim$b,sim$b/sim$a)
sim$efficiency.gap <- abs(sim$wasted.a-sim$wasted.b)/nrow(sim)
# split at 0.34
packed <- sim[sim$vote.ratio<0.34,]
cracked <- sim[sim$vote.ratio>=0.34,]
f1 <- lm(efficiency.gap~vote.ratio,packed)
f2 <- lm(efficiency.gap~vote.ratio,cracked)
ggplot(sim) + geom_point(aes(x=vote.ratio,y=efficiency.gap)) + ggtitle("Simulated Results")
```

The plot demonstrates an interesting piecewise function where the efficiency gap peaks at a vote ratio just above $0$ and decreases dramatically until it reaches a minimum at $0.34$. The segment where $VR < 0.34$ can be seen as those districts that are “packed” – where the majority party wins by a margin greater than $2:1$.

Near $VR = 0.34$, the efficiency gap is close to $0$, since the two parties waste about the same number of votes – there are about as many votes for the minority party as there are for the winning party in excess of a simple majority.

When $VR \geq 0.34$, the efficiency gap increases to its maximum value as the vote ratio approaches 1. We can consider these districts as “cracked”. This segment includes districts where the majority party has a comfortable vote ratio in their favor: $0.34 \leq VR \leq 0.8$. This ranges from a margin of victory of $33$ points to as few as $10$ points. The region $0.8 < VR \leq 1$ indicates a high efficiency gap, but the margin of victory is less than 10 points, so these districts are competitive and unlikely to be intentionally gerrymandered.

The next plot shows the results for every district in the 2012 congressional elections that ran a Democratic and a Republican candidate. I split the results between the winning parties: 

```{r,echo=FALSE}
excUnopposed <- subset(districtData2012,vote.ratio>0) 
# exclude districts where a candidate ran unpposed (with a major party challenger)
ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=excUnopposed, aes(x=vote.ratio,y=efficiency.gap,color=majority)) +
  facet_grid(majority ~ .,labeller = label_both) + 
  scale_colour_manual(values=c("blue","red")) + 
  ggtitle("2012 Congressional Results by Party")
```
                          
Here we see two interesting patterns: (1) most districts, regardless of party, are on the “cracking” spectrum and (2) there are very few Republican majority districts on the “packing” spectrum. There seems to be a hard cutoff at a $VR = 0.25$ for Republican districts, indicating that Republicans are far less likely to be packed into districts. Unfortunately, we cannot detect gerrymandering by identifying where a single district falls along this function. An individual district may favor a party $2:1$ simply by nature of a state’s partisan divide. We can however identify gerrymandering by examining the distribution of a state's districts along the function. If there is a clear partisan divide between low-efficiency and high-efficiency districts, we may determine that a state is intentionally gerrymandered. In order to do so, we will examine the results of a few states over the course of several elections. A good indicator of whether a state might be gerrymandered is whether there is one or more seats misapportioned for the state as a whole. 

### Data Acquisition

The data I used to assess gerrymandering and misapportionment was compiled by *Time* magazine. Thanks to their efforts, the results of the biennial congressional elections from 2004-2012 can be accessed as csv or json files on their [Github Repo](https://github.com/TimeMagazine/congressional-election-results/tree/master/data). The data required some scrubbing and manipulation to get consistent results. I chose to look at the results of the four elections from 2006-2012 in order to see how misapportionment changed over time in particular states. Since these elections bridge the decennial census, I expected there to be significant changes over this time period. For each of the elections, I tidied the results by party by grouping local affiliates of parties, or naming variations on the ballot to be simply "Democratic" or "Republican". For example, Minnesota's Democratic-Farmer Labor party is the state affiliate of the US Democratic Party, and thus became "Democratic". There are also some states that allow "electoral fusion", so a candidate may be on the ballot for more than one party. Cases like "Democratic, Working Families" and "Republican, Conservative" simply became "Democratic" and "Republican". I performed a number of aggregations on the data to derive totals for votes and wasted votes on the district, state, and national levels. I then calculated the efficiency gap and seat misapportionment on the state level using the approach outlined by Stephanopoulus and McGhee and compared it with my technique of assigning the efficiency gap in each district as the portion of a seat won by the majority party due to partisan asymmetry.

We will compare these measures by looking at the 2012 election. As we see below, the statewide efficiency gap does not serve as a good indicator of gerrymandering since the size of a state's congressional delegation determines how many seats are effectively misapportioned. In this table, "State EG" is the original misapportionment metric - the product of the statewide efficiency gap and the total number of seats in a state. The column "District EG" is my measure of the aggregate seat advantage in each state. 

```{r,echo=FALSE}
display <- join(stateData2012[,c(1,7,17)],sumAdv2012,by="state",type="left")
display[,c(2,5)] <- round(display[,c(2,5)],2)
display <- display[,c(1,2,3,5,4)]
colnames(display)[2:5] <- c("State EG","Seat Advantage","Agg. District EG","Seat Advantage")
kable(head(display,10),row.names = F)
```

The figures are similar in most cases, but there there is significant variation for Georgia, California, and Arizona. In these cases, the party that gains from the misapportioment is actually flipped! \footnote{The results may seem at odds with the current political majorities in these states, but they do make sense in light of the redistricting following the 2010 census. Arizona, for example, has a significant Republican majority in the state legislature but districting falls to the Arizona Independent Redistricting Committee. The AIRC passed a plan in early 2012 that favored Democrats and was upheld after multiple judicial challenges by the state's Republicans. In Georgia, the Repubicans hold a significant majority in the state legislature, but the misapportionment may be a holdover from earlier gerrymandering in the Democrats' favor. The redistricting following the 2010 census was the first time in the history of the state that Republicans controlled the process.}

Ranking the top ten misapportioned states for each metric, we see that the two methods return fairly similar results, with some variation in order. My metric ranks gerrymandering in Texas considerably lower, landing California the tenth rank instead. The top 10 states for each metric in descending order:

```{r,echo=FALSE}
display <- display[order(-display["State EG"]),]
display2 <- display[order(-display["Agg. District EG"]),]
kable(cbind(head(display[,c(1,2)],10),head(display2[,c(1,4)],10)),row.names = F)
```

To compare these metrics with the Schwartzberg and Polsby-Popper measures of geometric compactness, I used the shapefiles for congressional districts provided by the US Census Bureau. This allowed me to measure the perimeter and area for each district and evaluate the two compactness measures. Using the shapefiles for the 113th Congress, which followed the 2012 election, I calculated the Schwartzberg and Polsby-Popper values for each district and then calculated the state average. The results are quite different. Here we see the ten least compact states by the Polsby-Popper measure are lead by Alaska, which has only one congressional seat and cannot be gerrymandered. 

The Schwartzberg measure is not only inconsistent with the seat misapportionment metric, it also differs considerably from Polsby-Popper. There are only four states that rank in the top ten on both geometric indices, . Eliminating Alaska, the top five on ths Schwartzberg index are not in the top ten on the Polsby-Popper index. The rankings also seems to be sensitive to states with a small number of districts. While these measures may be useful in identifying irregularly shaped districts, these results demonstrate that the compactness measures are very inconsistent and should not be used at the state level to idenfity patterns of gerrymandering.

```{r,echo=FALSE}
temp <- tempfile()  # 110th & 111th Congressional District Shapefiles
download.file("http://cdmaps.polisci.ucla.edu/shp/districts113.zip", #113 congress = 2012 election
              temp)  # See http://www.census.gov/geo/www/cob/cd110.html#shp
unzip(temp)
shapeFile <- readShapeSpatial("districtShapes/districts113.shp")  # Load shapefile
suppressMessages(mapObject <- fortify(shapeFile))  # Convert to a data.frame
mapObject <- data.frame(mapObject, shapeFile@data[mapObject$id, ])

### Calculate district area and perimeter length ###

mapObject$piece <- as.character(mapObject$piece)
mapObject$stateCD <- with(mapObject, paste(STATENAME, DISTRICT))
mapObject$Area <- mapObject$Perimeter <- NA
uniqueCDs <- sort(unique(mapObject$stateCD))

for(cd in uniqueCDs){  
  cdShape <- mapObject[mapObject$stateCD == cd, ]
  cdPoly <- SpatialPolygons(list(Polygons(lapply(split(cdShape[, c("long", "lat")],
                                                       cdShape$piece), Polygon), ID = "b")))
  owinObject <- try(as(cdPoly, "owin"))  
  if(class(owinObject) == "try-error"){next()}  
  mapObject[mapObject$stateCD == cd, "Area"] <- area.owin(owinObject)
  mapObject[mapObject$stateCD == cd, "Perimeter"] <- perimeter(owinObject)
}

mapObject$Schwartzberg <- with(mapObject, Perimeter / ((Perimeter^2)/(4*pi)))
mapObject$Polsby.Popper <- with(mapObject, Area / ((Perimeter^2)/(4*pi)))

eachPP <- aggregate(Polsby.Popper ~ STATENAME + DISTRICT,mapObject,mean)
statePP <- aggregate(Polsby.Popper ~ STATENAME,eachPP,mean)
eachSB <- aggregate(Schwartzberg ~ STATENAME + DISTRICT,mapObject,mean)
stateSB <- aggregate(Schwartzberg ~ STATENAME,eachSB,mean)
kable(cbind(rank=1:10,head(statePP[order(statePP$Polsby.Popper),],10),rank=1:10,
      head(stateSB[order(stateSB$Schwartzberg),],10)),row.names=F)
```

### Evaluating State Patterns

In order to evaluate how effective these rankings were at identifying gerrymandering, I took a closer look at the distribution of efficiency gaps between parties in individual states. North Carolina ranked high on our misapportionment index and on the Polsby-Popper index. The plots below shows the dramatic shift in the state's seat misapportionment and demonstrates a clear case of partisan gerrymandering. 

In 2006, the Republicans in North Carolina had approximately one seat in their favor. We see that all districts are on the "cracking" spectrum. There is no discernible pattern between parties in the vote ratio, or how competitive their majority districts are. The next cycle shows a downward shift in the efficiency gap in both parties' majority districts, decreasing the statewide misapportionment to 0.2 seats in favor of the Democrats. Clear patterns of gerrymandering emerge and shift dramatically in the 2010 and 2012 elections. Democrats gained significant advantages in 2010. With the exception of a Republican victory in one very competitive district, the Democratic majority districts win in more competitive districts, and with higher efficiency gaps than all of the other Republican majority districts. This maximized their advantage in the state and bumped the seat misapportionment to 1.6 seats in the Democrats' favor. The 2012 election, on the heels of the decennial census, saw a complete reversal in the Republicans' favor. The Republicans won districts with higher efficiency gaps than the Democrats, and each with more extreme averages. We can see a slight shift upwards in the efficiency gap for the Republican-majority districts in 2012 over those Democratic-majority districts in 2010. Likewise, the efficiency gaps for the Democratic-majority districts in 2012 are lower than the Republican majority districts in 2010. This all lead to a radical swing in the misapportionment to 2.8 seats in the Republicans' favor. We should also note that there does seem to be a bounding vote ratio of 0.8 for whichever party has the seat advantage. While winning a district with a high vote ratio adds significantly to the advantage for a party trying to maximize the efficiency gap, there is a point at which the vote ratio makes the district too competitive to be secure. In each of the four years, it appears that the party with the seat advantage does well to avoid that risk.

```{r,echo=FALSE}
NC2006 <- subset(districtData2006,state=="NC" & vote.ratio>0)
NC2008 <- subset(districtData2008,state=="NC" & vote.ratio>0)
NC2010 <- subset(districtData2010,state=="NC" & vote.ratio>0)
NC2012 <- subset(districtData2012,state=="NC" & vote.ratio>0)

p1 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=NC2006, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("NC 2006 : +", round(NC2006$state.seats.misapportioned,1),"seats for",
                ifelse(NC2006$state.seat.favor=="R","R","D")))
p2 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=NC2008, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("NC 2008 : +", round(NC2008$state.seats.misapportioned,1),"seats for",
                ifelse(NC2008$state.seat.favor=="R","R","D")))
p3 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=NC2010, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("NC 2010 : +", round(NC2010$state.seats.misapportioned,1),"seats for",
                ifelse(NC2010$state.seat.favor=="R","R","D")))
p4 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=NC2012, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("NC 2012 : +", round(NC2012$state.seats.misapportioned,1),"seats for",
                ifelse(NC2012$state.seat.favor=="R","R","D")))

grid.arrange(p1, p2, p3, p4, ncol = 2, nrow=2)
```
   
\newpage

Michigan demonstrates a similar pattern. It had about three seats misapportioned in 2012 by my measure, but did not rank highly by geometric compactness for the same period. It was 28th on the Polsby-Popper index and 36th on Schwartzberg. Michigan was very clearly gerrymandered in the Republicans' favor in 2006. They held a 3.7 seat advantage and the pattern to maximize the efficiency of Republican majority districts over Democratic majority districts is clear. This extreme pattern took its toll on the Republicans when the Democrats flipped two of the more competitive districts, lowering the statewide misapportionment to about one seat. The Republican advantage decreased further in 2010, only to re-entrench in 2012. Following the census, the Republicans nearly replicated the efficiency gap pattern in 2006 and increased their advantage to about three seats. It's important to note that Michigan also lost one seat in the 2010 Census apportionment - the 15th district - which resulted in one fewer Democratic seat. 

\vspace{5mm}

```{r,echo=FALSE}
MI2006 <- subset(districtData2006,state=="MI" & vote.ratio>0)
MI2008 <- subset(districtData2008,state=="MI" & vote.ratio>0)
MI2010 <- subset(districtData2010,state=="MI" & vote.ratio>0)
MI2012 <- subset(districtData2012,state=="MI" & vote.ratio>0)

p5 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=MI2006, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("MI 2006 : +", round(MI2006$state.seats.misapportioned,1),"seats for",
                ifelse(MI2006$state.seat.favor=="R","R","D")))
p6 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=MI2008, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("MI 2008 : +", round(MI2008$state.seats.misapportioned,1),"seats for",
                ifelse(MI2008$state.seat.favor=="R","R","D")))
p7 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=MI2010, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("MI 2010 : +", round(MI2010$state.seats.misapportioned,1),"seats for",
                ifelse(MI2010$state.seat.favor=="R","R","D")))
p8 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=MI2012, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("MI 2012 : +", round(MI2012$state.seats.misapportioned,1),"seats for",
                ifelse(MI2012$state.seat.favor=="R","R","D")))

grid.arrange(p5, p6, p7, p8, ncol = 2, nrow=2)
```

\vspace{5mm}

We see a nearly identical pattern in New Jersey, which also ranked low on both compactness indicies. Like North Carolina and Michigan, Republicans in New Jersey held a considerable seat advantage in 2006 by maximizing the efficiency gap in Republican majority districts and minimizing the efficiency of Democratic districts.

```{r,echo=FALSE}
NJ2006 <- subset(districtData2006,state=="NJ" & vote.ratio>0)
NJ2008 <- subset(districtData2008,state=="NJ" & vote.ratio>0)
NJ2010 <- subset(districtData2010,state=="NJ" & vote.ratio>0)
NJ2012 <- subset(districtData2012,state=="NJ" & vote.ratio>0)

p9 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=NJ2006, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("NJ 2006 : +", round(NJ2006$state.seats.misapportioned,1),"seats for",
                ifelse(NJ2006$state.seat.favor=="R","R","D")))
p10 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=NJ2008, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("NJ 2008 : +", round(NJ2008$state.seats.misapportioned,1),"seats for",
                ifelse(NJ2008$state.seat.favor=="R","R","D")))
p11 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=NJ2010, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("NJ 2010 : +", round(NJ2010$state.seats.misapportioned,1),"seats for",
                ifelse(NJ2010$state.seat.favor=="R","R","D")))
p12 = ggplot() + 
  geom_line(data=sim, aes(x=vote.ratio,y=efficiency.gap)) +
  geom_point(data=NJ2012, aes(x=vote.ratio,y=efficiency.gap,color=majority,shape=majority)) + 
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ggtitle(paste("NJ 2012 : +", round(NJ2012$state.seats.misapportioned,1),"seats for",
                ifelse(NJ2012$state.seat.favor=="R","R","D")))

grid.arrange(p9, p10, p11, p12, ncol = 2, nrow=2)
```

We see the Republican advantage drop in 2008 and 2010 as the Democrats flipped a competitive district and increased the efficency gap in their majority districts. In 2010, the state approached partisan symmetry, but the state also lost a congressional seat following the 2010 Census apportionment. Although New Jersey is one of thirteen states where the power to redistrict is given to a commission rather than the state legislature, the process in 2011 was deadlocked along partisan lines, State Supreme Court Justice Stuart Rabner apppointed a tiebreaking member to the commission that voted in favor of the Republican plan to merge the 5th and 9th congressional districts. In 2010, these seats were held respectively by a Republican (2010: EG = 0.18) and a Democrat (2010: EG = 0.27). Between these two seats, the Democrats had a marginal seat advantage. Parts of the heavily Democratic 9th district (2010: VR = 0.62) were packed into the heavily Democratic 8th District (2010: VR = 0.58) and cracked into the heavily Republican 5th district (2010: VR = 0.50). From 2010 to 2012, this increased the efficiency gap in the Republican-held 5th from 0.18 to 0.38 and decreased the efficiency gap in the Democratic held 8th from 0.23 to 0.09, while also erasing a Democratic district from the map. In two years, the state shifted from partisan symmetry to a two seat misapportionment in favor of the Republican party. The plot for 2012 demonstrates a distribution that we can now identify as a classic gerrymandering pattern: seats will be misapportioned towards the party that maintains consistently high efficiency gaps in the districts that they win and low efficiency gaps in districts that they lose. We examined three cases with the highest seat misapportionment and found that this pattern is at its most extreme when the minimum efficiency gap for the advantaged party exceeds the maximum efficiency gap for the disadvantaged party. 

From each of these three cases, it is clear the the district efficiency gap provides a consistent measure for seat misapportionment as well as identifying gerrymandering patterns within states.

\newpage

### Total Effect of Misapportionment

We can use also the district efficiency gap to calculate the total effect of seat misapportionment by aggregating seat advantages on the national level. The plot below shows that both parties have a number of seats misapportioned in their favor, but that the Republicans have benefited more from gerrymandering going back to at least 2004. 

```{r,echo=FALSE}
aggMis <- rbind(aggregate(state.seats.misapportioned~state.seat.favor,sumAdv2004,sum),
      aggregate(state.seats.misapportioned~state.seat.favor,sumAdv2006,sum),
      aggregate(state.seats.misapportioned~state.seat.favor,sumAdv2008,sum),
      aggregate(state.seats.misapportioned~state.seat.favor,sumAdv2010,sum),
      aggregate(state.seats.misapportioned~state.seat.favor,sumAdv2012,sum))
aggMis$year <- c(2004,2004,2006,2006,2008,2008,2010,2010,2012,2012)
colnames(aggMis) <- c("party","misapportioned.seats","year")
ggplot(aggMis) +
  geom_line(aes(x=year,y=misapportioned.seats,color=party)) + 
  scale_colour_manual(values=c("blue","red")) +
  ggtitle("Seats Misapportioned by Party")
  
```

The margin between the parties peaked in 2006 when Republicans held a 39 seat advantage, but decreased to a narrow gap by 2010 when only five more seats were gerrymandered in their favor. What's interesting to note here is that the extent of seat misapportionment varies between elections, not just decennial redistricting. Although the partisan divide seems to grow again following the 2010 census, the change between elections demonstrates that seat misapportionment isn't static between redistricting. We see that the misapportionment for a particular state seems to oscillate over time. For these plots, misapportioned seats for the Democrats are negative values, so we can visualize the total shift in seat misapportionment in election years where there the total advantage changes hands. 

```{r,echo=FALSE}
NJ <- rbind(subset(sumAdv2004,state=="NJ"),
            subset(sumAdv2006,state=="NJ"),
            subset(sumAdv2008,state=="NJ"),
            subset(sumAdv2010,state=="NJ"),
            subset(sumAdv2012,state=="NJ"))
NJ$year <- seq(2004,2012,by=2)
colnames(NJ)[2:3] <- c("favor","seats.misapportioned")
for(i in nrow(NJ)){ if (NJ$favor[i]=="D"){ NJ$seats.misapportioned[i] <- -NJ$seats.misapportioned[i]}}
plotNJ <- ggplot(NJ) +
  geom_point(aes(x=year,y=seats.misapportioned,color=favor)) +
  scale_colour_manual(values=c("red","blue")) +
  scale_shape_manual(values = c(1,2)) +
  ylim(-5,5) +
  geom_hline(aes(yintercept=mean(NJ$seats.misapportioned)),linetype=2) + 
  ylab("misap.sts") +
  ggtitle("NJ Gerrymandering, 2004-2012")

AL <- rbind(subset(sumAdv2004,state=="AL"),
            subset(sumAdv2006,state=="AL"),
            subset(sumAdv2008,state=="AL"),
            subset(sumAdv2010,state=="AL"),
            subset(sumAdv2012,state=="AL"))
AL$year <- seq(2004,2012,by=2)
colnames(AL)[2:3] <- c("favor","seats.misapportioned")
for(i in 1:nrow(AL)){ if (AL$favor[i]=="D"){ AL$seats.misapportioned[i] <- -AL$seats.misapportioned[i]}}
plotAL <- ggplot(AL) +
  geom_point(aes(x=year,y=seats.misapportioned,color=favor)) +
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ylim(-5,5) +
  geom_hline(aes(yintercept=mean(AL$seats.misapportioned)),linetype=2) + 
  ylab("misap.sts") +
  ggtitle("AL Gerrymandering, 2004-2012")

AZ <- rbind(subset(sumAdv2004,state=="AZ"),
            subset(sumAdv2006,state=="AZ"),
            subset(sumAdv2008,state=="AZ"),
            subset(sumAdv2010,state=="AZ"),
            subset(sumAdv2012,state=="AZ"))
AZ$year <- seq(2004,2012,by=2)
colnames(AZ)[2:3] <- c("favor","seats.misapportioned")
for(i in 1:nrow(AZ)){ if (AZ$favor[i]=="D"){ AZ$seats.misapportioned[i] <- -AZ$seats.misapportioned[i]}}
plotAZ <- ggplot(AZ) +
  geom_point(aes(x=year,y=seats.misapportioned,color=favor)) +
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ylim(-5,5) +
  geom_hline(aes(yintercept=mean(AZ$seats.misapportioned)),linetype=2) + 
  ylab("misap.sts") +
  ggtitle("AZ Gerrymandering, 2004-2012")

NY <- rbind(subset(sumAdv2004,state=="NY"),
            subset(sumAdv2006,state=="NY"),
            subset(sumAdv2008,state=="NY"),
            subset(sumAdv2010,state=="NY"),
            subset(sumAdv2012,state=="NY"))
NY$year <- seq(2004,2012,by=2)
colnames(NY)[2:3] <- c("favor","seats.misapportioned")
for(i in 1:nrow(NY)){ if (NY$favor[i]=="D"){ NY$seats.misapportioned[i] <- -NY$seats.misapportioned[i]}}
plotNY <- ggplot(NY) +
  geom_point(aes(x=year,y=seats.misapportioned,color=favor)) +
  scale_colour_manual(values=c("red","blue")) +
  scale_shape_manual(values = c(1,2)) +
  ylim(-5,5) +
  geom_hline(aes(yintercept=mean(NY$seats.misapportioned)),linetype=2) + 
  ylab("misap.sts") +
  ggtitle("NY Gerrymandering, 2004-2012")

OH <- rbind(subset(sumAdv2004,state=="OH"),
            subset(sumAdv2006,state=="OH"),
            subset(sumAdv2008,state=="OH"),
            subset(sumAdv2010,state=="OH"),
            subset(sumAdv2012,state=="OH"))
OH$year <- seq(2004,2012,by=2)
colnames(OH)[2:3] <- c("favor","seats.misapportioned")
for(i in 1:nrow(OH)){ if (OH$favor[i]=="D"){ OH$seats.misapportioned[i] <- -OH$seats.misapportioned[i]}}
plotOH <- ggplot(OH) +
  geom_point(aes(x=year,y=seats.misapportioned,color=favor)) +
  scale_colour_manual(values=c("red","blue")) +
  scale_shape_manual(values = c(1,2)) +
  ylim(-5,5) +
  geom_hline(aes(yintercept=mean(OH$seats.misapportioned)),linetype=2) + 
  ylab("misap.sts") +
  ggtitle("OH Gerrymandering, 2004-2012")

PA <- rbind(subset(sumAdv2004,state=="PA"),
            subset(sumAdv2006,state=="PA"),
            subset(sumAdv2008,state=="PA"),
            subset(sumAdv2010,state=="PA"),
            subset(sumAdv2012,state=="PA"))
PA$year <- seq(2004,2012,by=2)
colnames(PA)[2:3] <- c("favor","seats.misapportioned")
for(i in 1:nrow(PA)){ if (PA$favor[i]=="D"){ PA$seats.misapportioned[i] <- -PA$seats.misapportioned[i]}}
plotPA <- ggplot(PA) +
  geom_point(aes(x=year,y=seats.misapportioned,color=favor)) +
  scale_colour_manual(values=c("blue","red")) +
  scale_shape_manual(values = c(1,2)) +
  ylim(-5,5) +
  geom_hline(aes(yintercept=mean(PA$seats.misapportioned)),linetype=2) + 
  ylab("misap.sts") +
  ggtitle("PA Gerrymandering, 2004-2012")

grid.arrange(plotNY, plotOH, plotNJ, plotPA, plotAZ, plotAL, ncol=2, nrow=3)
```

What's remarkable about this oscillating pattern is that it holds for states that register high on the index of misapportionment for the District Efficiency Gap as well as those that don't. New York, Ohio, New Jersey, and Pennsylvania rank in the top ten misapportioned districts following the 2012 elections. We see that the effect of misapportionment is consistently in one party's favor over the course of five elections, but the extent of misapportionment ebbs and flows over time. The dashed lines in the plots represent the average misapportionment for the state over the five elections. Arizona and Alabama rank fairly low on the misapportionment index, but also demonstrate the oscillating pattern. The key difference is that that the misapportionment in these two states oscillates around a near-zero mean (perfect partisan symmetry) and therefore alternately favors both parties. Stephanopoulus and McGhee suggest limiting gerrymandering by setting a maximum level of misapportionment to two seats. I think this is a valuable limitation, but I would modify the maximum to an average of one seat in a party's favor over the course of five elections. As we see for New York, Ohio, New Jersey, and Pennsylvania, an average above two seats not only keeps the misapportionment in a party's favor for an extended period, but it also means that the peak misapportionment will far exceed the average (five seats in New York in 2006 and five seats for Pennsylvania in 2012). A maximum average of one seat will be more likely to curb the extreme fluctations of seat misapportionment between districting cycles. The misapportionment cycle in Pennsylvania highlights the importance of looking at the average misapportionment rather than the results of any individual election. The cycle bottoms out in 2008 with less than half a seat in the Democrats' favor. This single election would make Pennsylvania's districting appear to be symmetric, but the five-year results show that misapportionment actually oscillates around a mean of 2.4 seats in the Republican's favor.

\newpage

### Further Considerations

There are some limitations to the calculation of the Efficiency Gap that merit further consideration.

1. It assumes a two-party model. While the Republican and Democratic Parties dominate nationally, there are some districts where independent candidates have garnered a significant portion of the vote. In the 2012 elections, the Green Party won 16% in Arkansas's third congressional district (AR-3) and Libertarian candidates won between 15-32% in AZ-7, KS-3, LA-4, LA-6, TX-17, and TX-19. Calculating the efficiency gap is straightforward for two parties, but is less so for three or more parties. It would be valuable to extend the efficiency gap for more pluralistic districts to further our understanding of partisan assymetry, and the effect it has on third parties.

2. The efficiency gap does not explain uncontested districts. Since the measure calculates the difference in wasted votes, uncontested districts should only exist when the party in control of a state legislature wants to pack the minority party into an overwhelmingly safe district and waste very few votes of their own. It would be, in effect, a maximally efficient form of packing. The results for the 2012 election demonstrate that this isn’t the case: there were three uncontested Democratic seats in Massachusetts, where Democrats dominate the state legislature and four uncontested Republican seats in Texas, where Republicans control the legislature. There was also a mix of uncontested seats held by both Parties in both Florida and California. Whether uncontested districts are vestige of past gerrymandering patterns - essentially, districts that have been packed for a number of consecutive election cycles - merits further consideration.

Article Sources:

[“Here’s how we can end Gerrymandering Once and for All”](https://newrepublic.com/article/118534/gerrymandering-efficiency-gap-better-way-measure-gerrymandering) by Nicholas Stephanopoulus

[“Partisan Gerrymandering and the Efficiency Gap”](http://papers.ssrn.com/sol3/papers.cfm?abstract_id=2457468) by Nicholas Stephanopoulus and Erin McGhee

["Time Magazine's GitHub Repo: Congressional Election Results"](https://github.com/TimeMagazine/congressional-election-results) by Chris Wilson, *Time Magazine*

["Wesberry v. Sanders"](https://scholar.google.com/scholar_case?case=6357954371173516293) Wesberry v. Sanders, 376 US 1 - Supreme Court 1964

["Supreme Court upholds Arizona redistricting plan"](https://www.washingtonpost.com/politics/courts_law/supreme-court-upholds-arizona-redistricting-plan/2016/04/20/426ac408-0715-11e6-b283-e79d81c63c1b_story.html) by Robert Barnes

["GA. GOP in charge of redistricting for 1st time"](http://www.cbs46.com/story/15180168/ga-gop-in-charge-of-redistricting-for-1st-time) CBS46, Atlanta

["All About Redistricting"](http://redistricting.lls.edu/states-NJ.php) by Professor Justin Levitt's, Loyola Law School, Loyola Marymount University
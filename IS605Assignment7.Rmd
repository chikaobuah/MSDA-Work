---
title: "IS605Assignment7"
output: html_document
---
To calculate the Expected Value of X, based on a set of values and their probability distribution, we will build
a function that takes in a dataframe, that should contain the values and the respective probabilities.
We should construct any input as a two-column data frame. 

First, let's construct a function that sums the all of the outcomes by their respective probabilities:

```{r}
EofX <- function(df){
  sum <- 0
  for (i in 1:nrow(df)){
    sum <- sum + df[i,1]*df[i,2]
  }
  print(sum)
}
```

And to calculate the standard deviation of a probability distribution:

```{r}
SDofX <- function(df){
  var <- 0
  for (i in 1:nrow(df)){
    var <- var + ((df[i,1]-EofX(df))^2)*df[i,2]
    sd <- sqrt(var)
  }
  print(sd)
}
```

We can build a function that will give us the standard deviation of a set of random variables. Note that this formula TYPE IN LATEX, will give us the population standard deviation

```{r}
SDpop <- function(x){
  print(sqrt(mean(x^2) - mean(x)^2))
}
SDofX(1:10)
```

Our result differs slightly from the built-in function in R, which will return the sample standard deviation.

```{r}
sd(1:10)
```

We can construct a function to calculate sample standard deviation:

```{r}
SDsample <- function(x){
  print(sqrt((mean(x^2) - mean(x)^2)/(length(x)-1)))
}
SDsample(1:10)
```

Now we can test the function with a carefully constructed probability distribution. We must make sure that 
(1) each output has a corresponding probability and (2) all of the probabilities add up to 1.

```{r}
outcomes <- c(3,5,7,2,2,2,5,7,8,9)
values <- c(0.05,0.10,0.01,0.09,0.20,0.02,0.03,0.30,0.01,0.19)
length(outcomes) == length(values) # Check that they are the same length
sum(values) # Check that they add up to one
probDist <- as.data.frame(cbind(outcomes,values))
probDist
```

Now we will build a function that will preserve a rolling estimate of mean and standard deviation:

```{r}
stored <- vector(mode="numeric", length=0) #initialize the vector of stored values
stats <- function(x){
  stored <<- c(stored,x) # here we use the <<- "superassignment" operator to store in the parent environment
    return(list(ExpectedValue = mean(stored),StandardDeviation = sd(stored)))
}
# Now we can test it
g <- 3:5
h <- 4:6
i <- 10:31
stats(g) 
stats(g) # We can see that running the same vector of values preserves the mean and alters the st. deviation
stats(g)
stats(h)
stats(i)
```

If we want to get the current mean or standard deviation without adding new data, we can simply call them from the "stored" data with the base R functions

```{r}
mean(stored)
sd(stored)
```

And if we want to clear the previous data and start the function anew:

```{r}
rm(stored) # Clears previous data
```

Let's set some random variables 

```{r}
g <- sample(40)
h <- sample(40)
covariance <- function(x,y){
  mean(x*y) - mean(x)*mean(y)
}
correlation <-function(x,y){
  (mean(x*y) - mean(x)*mean(y))/(sd(x)*sd(y))
}
# See if they're close to the built-in functions
covariance(g,h)
cov(g,h) # built-in
correlation(g,h)
cor(g,h) # built-in
```

```{r}
setwd("/Users/davidstern/Documents")
data <- read.table("auto-mpg.data",header=F)
data <- as.matrix(data)
fiveVars <- matrix(data[,1:5],ncol=5)
colnames(fiveVars) <- c("displacement","horsepower","weight","acceleration","mpg")
```

```{r}
corrMatrix <- matrix(rep(0,25),ncol=5)
colnames(corrMatrix) <- colnames(fiveVars)
rownames(corrMatrix) <- colnames(fiveVars)
for (i in 1:ncol(corrMatrix)) {
    for (j in 1:nrow(corrMatrix)) {
      corrMatrix[i,j] <- correlation(fiveVars[,i],fiveVars[,j])
      }
    }
corrMatrix

```

We can test this against a correlation matrix constructed with the built-in function:

```{r}
cor(fiveVars[,1:5])
```

Our correlation matrix seems quite accurate, although all of the values on the diagonals should be exactly 1.
The values seem to only be less than three-thousandths of one point off.

Now we will build our covariance matrix.

```{r}
covMatrix <- matrix(rep(0,25),ncol=5)
colnames(covMatrix) <- colnames(fiveVars)
rownames(covMatrix) <- colnames(fiveVars)
for (i in 1:ncol(covMatrix)) {
    for (j in 1:nrow(covMatrix)) {
      covMatrix[i,j] <- covariance(fiveVars[,i],fiveVars[,j])
      }
    }
covMatrix
```

It appears that this covariance matrix does past the symmetry test. For each entry Mi,j
 covMatrix[i,j] == covMatrix[j,i]

We can test this against a correlation matrix constructed with the built-in function:

```{r}
cov(fiveVars[,1:5])
```